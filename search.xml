<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS内购相关封装]]></title>
    <url>%2F2019%2F05%2F28%2FiOS%E5%86%85%E8%B4%AD%E7%9B%B8%E5%85%B3%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[将内购相关d功能封装成单例类，直接上代码.h代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import &lt;Foundation/Foundation.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@protocol YYAInAppPurchaseToolDelegate &lt;NSObject&gt;/*** TODO: System error.*/- (void)IAPToolSysWrong;/*** 已刷新可购买商品** @param products 商品数组*/- (void)IAPToolGotProducts:(NSMutableArray *)products;/*** 购买成功** @param productID 购买成功的商品ID*/- (void)IAPToolBoughtProductSuccessedWithProductID:(NSString *)productIDandInfo:(NSDictionary *)infoDic;;/*** 取消购买** @param productID 商品ID*/- (void)IAPToolCanceldWithProductID:(NSString *)productID;/*** 购买成功，开始验证购买** @param productID 商品ID*/- (void)IAPToolBeginCheckingdWithProductID:(NSString *)productID;/*** 重复验证** @param productID 商品ID*/- (void)IAPToolCheckRedundantWithProductID:(NSString *)productID;/*** 验证失败** @param productID 商品ID*/- (void)IAPToolCheckFailedWithProductID:(NSString *)productIDandInfo:(NSData *)infoData;/*** 恢复了已购买的商品（永久性商品）** @param productID 商品ID*/- (void)IAPToolRestoredProductID:(NSString *)productID;@endNS_ASSUME_NONNULL_BEGIN@interface YYAInAppPurchaseTool : NSObjecttypedef void(^BoolBlock)(BOOL successed,BOOL result);typedef void(^DicBlock)(BOOL successed,NSDictionary *result);/*** 代理*/@property(nonatomic,weak) id &lt;YYAInAppPurchaseToolDelegate&gt; delegate;/*** 购买完后是否在iOS端向服务器验证一次,默认为YES*/@property(nonatomic)BOOL CheckAfterPay;/*** 单例** @return YQInAppPurchaseTool*/+(YYAInAppPurchaseTool *)defaultTool;/*** 询问苹果的服务器能够销售哪些商品** @param products 商品ID的数组*/- (void)requestProductsWithProductArray:(NSArray *)products;/*** 用户决定购买商品** @param productID 商品ID*/- (void)buyProduct:(NSString *)productID;/*** 恢复商品（仅限永久有效商品）*/- (void)restorePurchase;@endNS_ASSUME_NONNULL_END .m代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#import &quot;YYAInAppPurchaseTool.h&quot;#ifdef DEBUG#define checkURL @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;#else#define checkURL @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;#endif@interface YYAInAppPurchaseTool ()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;/*** 商品字典*/@property(nonatomic,strong)NSMutableDictionary *productDict;@end@implementation YYAInAppPurchaseToolstatic YYAInAppPurchaseTool *storeTool;/// 单例+ (YYAInAppPurchaseTool *)defaultTool &#123;if(!storeTool)&#123;storeTool = [YYAInAppPurchaseTool new];[storeTool setup];&#125;return storeTool;&#125;#pragma mark 初始化- (void)setup &#123;self.CheckAfterPay = YES;// 设置购买队列的监听器[[SKPaymentQueue defaultQueue] addTransactionObserver:self];&#125;/// 询问苹果的服务器能够销售哪些商品- (void)requestProductsWithProductArray:(NSArray *)products &#123;NSLog(@&quot;开始请求可销售商品&quot;);// 能够销售的商品NSSet *set = [[NSSet alloc] initWithArray:products];// &quot;异步&quot;询问苹果能否销售SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:set];request.delegate = self;// 启动请求[request start];&#125;#pragma mark 获取询问结果，成功采取操作把商品加入可售商品字典里/*** 获取询问结果，成功采取操作把商品加入可售商品字典里** @param request 请求内容* @param response 返回的结果*/- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response &#123;if (self.productDict == nil) &#123;self.productDict = [NSMutableDictionary dictionaryWithCapacity:response.products.count];&#125;NSMutableArray *productArray = [NSMutableArray array];for (SKProduct *product in response.products) &#123;//NSLog(@&quot;%@&quot;, product.productIdentifier);// 填充商品字典[self.productDict setObject:product forKey:product.productIdentifier];[productArray addObject:product];&#125;//通知代理[self.delegate IAPToolGotProducts:productArray];&#125;#pragma mark - 用户决定购买商品/*** 用户决定购买商品** @param productID 商品ID*/- (void)buyProduct:(NSString *)productID &#123;SKProduct *product = self.productDict[productID];// 要购买产品(店员给用户开了个小票)SKPayment *payment = [SKPayment paymentWithProduct:product];// 去收银台排队，准备购买(异步网络)[[SKPaymentQueue defaultQueue] addPayment:payment];&#125;#pragma mark - SKPaymentTransaction Observer#pragma mark 购买队列状态变化,,判断购买状态是否成功/*** 监测购买队列的变化** @param queue 队列* @param transactions 交易*/- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions &#123;// 处理结果for (SKPaymentTransaction *transaction in transactions) &#123;NSLog(@&quot;队列状态变化 %@&quot;, transaction);// 如果小票状态是购买完成if (SKPaymentTransactionStatePurchased == transaction.transactionState) &#123;//NSLog(@&quot;购买完成 %@&quot;, transaction.payment.productIdentifier);if(self.CheckAfterPay)&#123;//需要向苹果服务器验证一下//通知代理[self.delegate IAPToolBeginCheckingdWithProductID:transaction.payment.productIdentifier];// 验证购买凭据[self verifyPruchaseWithID:transaction.payment.productIdentifier];&#125;else&#123;//不需要向苹果服务器验证//通知代理[self.delegate IAPToolBoughtProductSuccessedWithProductID:transaction.payment.productIdentifierandInfo:nil];&#125;// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125; else if (SKPaymentTransactionStateRestored == transaction.transactionState) &#123;//NSLog(@&quot;恢复成功 :%@&quot;, transaction.payment.productIdentifier);// 通知代理[self.delegate IAPToolRestoredProductID:transaction.payment.productIdentifier];// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125; else if (SKPaymentTransactionStateFailed == transaction.transactionState)&#123;// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];//NSLog(@&quot;交易失败&quot;);[self.delegate IAPToolCanceldWithProductID:transaction.payment.productIdentifier];&#125;else if(SKPaymentTransactionStatePurchasing == transaction.transactionState)&#123;NSLog(@&quot;正在购买&quot;);&#125;else&#123;NSLog(@&quot;state:%ld&quot;,(long)transaction.transactionState);NSLog(@&quot;已经购买&quot;);// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125;&#125;&#125;#pragma mark - 恢复商品/*** 恢复商品*/- (void)restorePurchase &#123;// 恢复已经完成的所有交易.（仅限永久有效商品）[[SKPaymentQueue defaultQueue] restoreCompletedTransactions];&#125;#pragma mark 验证购买凭据/*** 验证购买凭据** @param ProductID 商品ID*/- (void)verifyPruchaseWithID:(NSString *)ProductID &#123;// 验证凭据，获取到苹果返回的交易凭据// appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];// 从沙盒中获取到购买凭据NSData *receiptData = [NSData dataWithContentsOfURL:receiptURL];// 发送网络POST请求，对购买凭据进行验证//In the test environment, use https://sandbox.itunes.apple.com/verifyReceipt//In the real environment, use https://buy.itunes.apple.com/verifyReceipt// Create a POST request with the receipt data.NSURL *url = [NSURL URLWithString:checkURL];NSLog(@&quot;checkURL:%@&quot;,checkURL);// 国内访问苹果服务器比较慢，timeoutInterval需要长一点NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:20.0f];request.HTTPMethod = @&quot;POST&quot;;// 在网络中传输数据，大多情况下是传输的字符串而不是二进制数据// 传输的是BASE64编码的字符串/**BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性BASE64是可以编码和解码的*/NSString *encodeStr = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];NSString *payload = [NSString stringWithFormat:@&quot;&#123;\&quot;receipt-data\&quot; : \&quot;%@\&quot;&#125;&quot;, encodeStr];NSData *payloadData = [payload dataUsingEncoding:NSUTF8StringEncoding];request.HTTPBody = payloadData;// 提交验证请求，并获得官方的验证JSON结果NSURLSession *session = [NSURLSession sharedSession];// 4.根据会话对象，创建一个Task任务NSURLSessionDataTask *sessionDataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;NSLog(@&quot;从服务器获取到数据&quot;);NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:(NSJSONReadingMutableLeaves) error:nil];if (dict != nil) &#123;// 验证成功,通知代理// bundle_id&amp;application_version&amp;product_id&amp;transaction_id[self.delegate IAPToolBoughtProductSuccessedWithProductID:ProductIDandInfo:dict];&#125; else &#123;//验证失败,通知代理[self.delegate IAPToolCheckFailedWithProductID:ProductIDandInfo:data];&#125;&#125;];[sessionDataTask resume];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内购</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native开发环境的搭建（Mac）]]></title>
    <url>%2F2019%2F05%2F24%2FReact-Native%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88Mac%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装依赖1.先安装Homebrew（若已安装，可跳过）1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/ 2.安装node和webpack 12brew install nodebrew install webpack 测试node和webpack是否安装成功，可用如下命令进行检测。若本地安装，则会显示对应版本号。12node -vwebpack -v 3.设置国内镜像（常年开vpn的可以忽略）1npm config set disturl https://npm.taobao.org/dist --global 这里出错了，按提示走就可以，复制sudo那一行更改目录权限，再设置国内镜像。 4.安装RN：直接输入npm install -g react-native-cli。会因为权限不够而报错：npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules。所以我们直接输入下面两句话12sudo chown -R $(whoami) /usr/local/*npm install -g yarn react-native-cli 测试是否安装成功：1react-native -v 创建RN项目到本地1.创建RN项目1react-native init AwesomeProject 2.编译并运行 React Native 应用12cd AwesomeProjectreact-native run-ios 提示：如果 run-ios 无法正常运行，请使用 Xcode 运行来查看具体错误（run-ios 的报错没有任何具体信息）。第一次运行会比较慢，需要耐心等待一下 3.修改项目现在你已经成功运行了项目，我们可以开始尝试动手改一改了： 使用你喜欢的编辑器打开App.js并随便改上几行。 在 iOS 模拟器中按下⌘-R就可以刷新 APP并看到你的最新修改！（如果没有反应，请检查模拟器的 Hardware 菜单中，connect hardware keyboard 选项是否选中开启） 大功告成]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS截图那些事]]></title>
    <url>%2F2018%2F09%2F06%2FiOS%E6%88%AA%E5%9B%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[普通view截图12345678910+ (UIImage *)gjj_viewScreenShot:(UIView *)view &#123;UIGraphicsBeginImageContextWithOptions(CGSizeMake(view.frame.size.width, view.frame.size.height ), NO, 0.0);[view.layer renderInContext:UIGraphicsGetCurrentContext()];/// 返回一个基于当前图形上下文的图片UIImage *viewImage = UIGraphicsGetImageFromCurrentImageContext();/// 移除栈顶的基于当前位图的图形上下文UIGraphicsEndImageContext();return viewImage;&#125; tableView、collectionView等scrollView生成长截图实现步骤 保存scrollView截取前的偏移量及Frame 计算出你要截取的长图的高度及宽度，即scrollView的contentSize，将scrollView.frame设成scrollView.contentSize 渲染出scrollView整体（上下文），截取当前scrollView生成Image 恢复scrollView的偏移量及Frame 12345678910111213141516+ (UIImage *)gjj_scrollViewScreenShot:(UIScrollView *)scrollView &#123;UIImage *image = nil;UIGraphicsBeginImageContextWithOptions(scrollView.contentSize, YES, [UIScreen mainScreen].scale);CGPoint saveContentOffset = scrollView.contentOffset;CGRect savedFrame = scrollView.frame;scrollView.contentOffset = CGPointZero;scrollView.frame = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height);[scrollView.layer renderInContext:UIGraphicsGetCurrentContext()];scrollView.layer.contents = nil;image = UIGraphicsGetImageFromCurrentImageContext();scrollView.contentOffset = saveContentOffset;scrollView.frame = savedFrame;UIGraphicsEndImageContext();return image;&#125; webView生成长截图webView和scrollView的截图大同小异 12345678910111213141516+ (UIImage *)gjj_webViewScreenShot:(UIWebView *)webView &#123;UIImage *image = nil;UIGraphicsBeginImageContextWithOptions(webView.scrollView.contentSize, YES, [UIScreen mainScreen].scale);CGPoint saveContentOffset = webView.scrollView.contentOffset;CGRect savedFrame = webView.frame;webView.scrollView.contentOffset = CGPointZero;webView.frame = CGRectMake(0, 0, webView.scrollView.contentSize.width, webView.scrollView.contentSize.height);[webView.layer renderInContext:UIGraphicsGetCurrentContext()];webView.layer.contents = nil;image = UIGraphicsGetImageFromCurrentImageContext();webView.scrollView.contentOffset = saveContentOffset;webView.frame = savedFrame;UIGraphicsEndImageContext();return image;&#125; 图片拼接很多需求是截图附带二维码等进行分享。 123456789101112131415161718192021222324+ (UIImage *)gjj_addHeadImage:(UIImage *)headImage footImage:(UIImage *)footImage toMasterImage:(UIImage *)masterImage &#123;CGSize size;size.width = masterImage.size.width;CGFloat headProportion = !headImage?0:(headImage.size.width / headImage.size.height);CGFloat footProportion = !footImage?0:(footImage.size.width / footImage.size.height);CGFloat headHeight = !headImage? 0:masterImage.size.width/headProportion;CGFloat footHeight = !footImage? 0:footImage.size.width/footProportion;size.height = masterImage.size.height + headHeight + footHeight;UIGraphicsBeginImageContextWithOptions(size, YES, 0.0);if (headImage) &#123;[headImage drawInRect:CGRectMake(0, 0, masterImage.size.width, headHeight)];&#125;[masterImage drawInRect:CGRectMake(0, headHeight, masterImage.size.width, masterImage.size.height)];if (footImage) &#123;[footImage drawInRect:CGRectMake(0, masterImage.size.height + headHeight, masterImage.size.width, footHeight)];&#125;UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();return resultImage;&#125; 添加水印12345678910+ (UIImage *)gjj_addWaterImage:(UIImage *)waterImage toMasterImage:(UIImage *)masterImage waterImageRect:(CGRect)rect &#123;UIGraphicsBeginImageContextWithOptions(masterImage.size, NO, 0);[masterImage drawInRect:CGRectMake(0, 0, masterImage.size.width, masterImage.size.height)];/// 绘制水印图片到当前上下文[waterImage drawInRect:rect];UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return newImage;&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C实现】给出一个字符串，要求将其按照单词顺序进行反转]]></title>
    <url>%2F2018%2F08%2F21%2F%E3%80%90C%E5%AE%9E%E7%8E%B0%E3%80%91%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%A6%81%E6%B1%82%E5%B0%86%E5%85%B6%E6%8C%89%E7%85%A7%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目：给出一个字符串，要求将其按照单词顺序进行反转，比如如果是”the sky is blue”,那么反转之后的结果就是”blue is sky the”。问题分析： 每个单词长度不一致 空格需要特殊处理 使用C语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void swap (char chars[], int p, int q);void reverse (char chars[], int start, int end);void reverseWords(char strings[]);int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;char string[] = &quot;the sky is blue&quot;;reverseWords(string);&#125;return 0;&#125;void swap (char chars[], int p, int q) &#123;char temp = chars[p];chars[p] = chars[q];chars[q] = temp;&#125;void reverse (char chars[], int start, int end) &#123;NSLog(@&quot;%s&quot;,chars);int s = start;int e = end;while (s &lt; e) &#123;swap(chars, s, e);s += 1;e -= 1;&#125;NSLog(@&quot;%s&quot;,chars);&#125;void reverseWords(char strings[]) &#123;if ((int)strlen(strings) == 0) &#123;return;&#125;int start = 0, len = (int)strlen(strings);reverse(strings, 0, len - 1);for (int i = 0 ; i &lt; len; i++) &#123;if ((i == len - 1) || (strings[i + 1] == &apos; &apos;)) &#123;reverse(strings, start, i);start = i + 2;&#125;&#125;NSLog(@&quot;%s&quot;,strings);&#125; 控制台打印：2018-08-14 16:04:22.815076+0800 算法[6268:668783] blue is sky the]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLPreviewController]]></title>
    <url>%2F2018%2F05%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[QLPreviewController在iOS中用于方便预览文件，它支持的文件有： iWork文档 微软Office97以上版本的文档 RTF文档 PDF文件 图片文件 文本文件和CSV文件 使用的时候首先要引用#import &lt;QuickLook/QuickLook.h&gt;。 初始化： 12345_qlPreviewController = [[ QLPreviewController alloc]init]; _qlPreviewController.dataSource = self; _qlPreviewController.delegate = self; [self presentViewController:_qlPreviewController animated:YES completion:nil]; QLPreviewController类似于Tableview的使用方法，也是首先遵循代理和数据源代理。然后实现代理方法，如下： 123456789-(NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller&#123; return 2;&#125;-(id&lt;QLPreviewItem&gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;aa&quot; ofType:@&quot;doc&quot;]; NSURL *myDoucment = [NSURL fileURLWithPath:path]; return myDoucment;&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
  </entry>
</search>
