<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[macOS上搭建Flutter开发环境]]></title>
    <url>%2F2019%2F09%2F18%2FmacOS%E4%B8%8A%E6%90%AD%E5%BB%BAFlutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[系统要求要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: macOS (64-bit) 磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）. 工具: Flutter 依赖下面这些命令行工具. bash、mkdir、rm、git、curl、unzip、which 获取Flutter SDK 去flutter官网下载其最新可用的安装包，官网地址：https://flutter.io/sdk-archive/#macos。注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，可以去Flutter github项目下去下载安装包，地址：https://github.com/flutter/flutter/releases 。 解压安装包到你想安装的目录直接解压放到你想安装的目录就可以。或者使用命令行： 12cd ~/developmentunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 配置环境变量 打开终端工具，使用vim进行配置环境变量，命令如下： 1vim ~/.bash_profile 然后在终端添加以下三行： 123export PUB_HOSTED_URL=https://pub.flutter-io.cn # 国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn # 国内用户需要设置export PATH=/Users/sheffi/flutter/bin:$PATH 配置完成后，需要用source命令重新加载一下 ，具体命令如下： 1source ~/.bash_profile 完成这些步骤后，可以使用命令进行检测一下，是否安装成功。 1flutter -h 如图，说明一切安装顺利 检查开发环境 到这我们已经安装好了flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查： 1flutter doctor 因为我所有的东西都安装完，显示如下 第一次安装根据终端的提示进行安装相应的软件和插件。 安装 Xcode 要为iOS开发Flutter应用程序，您需要Xcode 9.0或更高版本: 安装Xcode 9.0或更新版本(通过链接下载或苹果应用商店). 配置Xcode命令行工具以使用新安装的Xcode版本 sudo xcode-select –switch /Applications/Xcode.app/Contents/Developer 对于大多数情况，当您想要使用最新版本的Xcode时，这是正确的路径。如果您需要使用不同的版本，请指定相应路径。 确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了. 使用Xcode，您可以在iOS设备或模拟器上运行Flutter应用程序。 安装Android Studio要在Android设备上构建并运行Flutter程序都需要先安装Android Studio，可以先自行下载并安装Android Studio，在此不再赘述。 Android Studio 配置与使用 a. 需要安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。 Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。 b. 安装步骤： 启动Android Studio。 打开插件首选项 (macOS：Preferences&gt;Plugins, Windows：File&gt;Settings&gt;Plugins)。 选择 Browse repositories…，选择 flutter 插件并点击 install。 重启Android Studio后插件生效。 c. 创建Flutter应用 选择 File&gt;New Flutter Project 。 选择 Flutter application 作为 project 类型, 然后点击 Next。 输入项目名称 (如 myapp)，然后点击 Next。 点击 Finish。 等待Android Studio安装SDK并创建项目。 d. 运行应用程序 定位到Android Studio工具栏 在 target selector 中, 选择一个运行该应用的Android设备。如果没有列出可用，请选择 Tools&gt;AVD Manager 并在那里创建一个。 在工具栏中点击 Run图标 如果一切正常, 您应该在您的设备或模拟器上会看到启动的应用程序： VS Code的配置与使用VS Code是一个轻量级编辑器，支持Flutter运行和调试。 a. 安装flutter插件 启动 VS Code。 调用 View&gt;Command Palette…。 输入 ‘install’, 然后选择 Extensions: Install Extension action。 在搜索框输入 flutter ，在搜索结果列表中选择 ‘Flutter’, 然后点击 Install。 选择 ‘OK’ 重新启动 VS Code。b. 验证配置 调用 View&gt;Command Palette… 输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ action。 查看“OUTPUT”窗口中的输出是否有问题c. 创建Flutter应用 启动 VS Code 调用 View&gt;Command Palette… 输入 ‘flutter’, 然后选择 ‘Flutter: New Project’ action 输入 Project 名称 (如myapp), 然后按回车键 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 最后附上学习链接：Flutter中文网]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十七款PDF在线转换器]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%8D%81%E4%B8%83%E6%AC%BEPDF%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目前最全合集，收藏备用。 1、smallPDF：https://smallpdf.com/2、Online OCR：https://www.onlineocr.net/3、PDF to Word Converter：https://www.pdftoword.com/4、加加PDF：https://www.addpdf.cn/pdf-to-word5、ilovePDF：https://www.ilovepdf.com/6、PDFconverter：https://www.pdfconverter.com7、PDFbao：http://www.pdfbao.com/8、PDF转换器：http://www.pdfdo.com/9、cloudconvert：https://cloudconvert.com/pdf-to-doc10、迅捷PDF转换器：https://app.xunjiepdf.com/11、ApowerPDF）：https://www.apowersoft.cn/pdf-editor12、PDF2go：https://www.pdf2go.com/zh/13、ABBYY FineReader：http://ocr.abbyy.cn/14、PDF.IO：https://pdf.io/tw/15、PDFtodoc：http://pdf2doc.com/zh/16、pdfcandy：https://pdfcandy.com/17、Docs.Zone：https://docs.zone/]]></content>
      <categories>
        <category>PDF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[译] 成为一个优秀程序员的101个小建议]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AF%91-%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84101%E4%B8%AA%E5%B0%8F%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[原文作者：Emma Wedekind 原文链接：dev.to/emmawedekin… 1. 善用google⭐作为一名程序员，你要知道如何搜索问题的答案。学会有效的使用google，你将节省大量开发时间。注：国内程序员还是要遵守规则的情况下跨过那道墙看看 2. 谨慎承诺超额交付⭐让你的团队知道一项任务需要三周的时间，并在两周内完成，这比让他们知道相反的情况要好。通过谨慎承诺和超额交付，你会建立信任。 3. 善待产品设计人员，他们是你的朋友产品设计人员为用户的痛点提供解决方案。向他们学习，团结一致地构建有效的产品。 4. 找到一名导师找到一个可以学习和借鉴的人。如果你需要技术指导，Coding Coach会是一个不错的地方。 5. 成为一名导师做一个别人可以学习和借鉴的人。你可以尝试在Coding Coach成为别人的导师。这个网站并不是很了解，请自行斟酌。国内厉害的程序员也很多，掘金，知乎上找也可以。 6. 写些有用的评论写下有用的回答而不是问为什么，mark和灌水也没什么意思。 7. 合理的命名变量和函数名函数和变量应该准确地表示它们的用途，因此myCoolFunction不是一个好名字。 8. 给自己放个假我们都需要时间来缓解压力。去一个你一直想去的地方放个假。你的大脑和同事都会感谢你的。 9. 删除无用代码⭐没有理由积累更多技术债务。 10. 学会阅读代码⭐阅读代码是一项非常宝贵的被低估的技能。 11. 找到健康工作和生活平衡点结束一周的工作之后，周末放松一下。关闭工作通知，删除手机上的应用程序。 12. 只安排必要的会议能用邮件解决的就没必要开会，如果非要开，也应该让会议简短高效。 13. 结对编程结对编程可以让你同时扮演老师和学生的角色。 14. 写好邮件邮件的内容应该简洁而清晰，抓住重点。没人会想看你的四页邮件，兄弟。 15. 加入社区⭐和志同道合的人在一起会激励你走出低谷。 16. 清理你的分支⭐清理你的版本控制分支，就像在你的岳父母来访之前清理你的房子一样。如果你不再需要，请删掉它，不删留着过年啊。 17. 接纳萌新包容点，不要告诉别人不够好，不能进入这个行业。每个人都是有价值。 18. 活到老学到老你选择了一个需要不断学习的职业，学会爱上它。 19. 永不言弃这并不容易，但是我们都是从同一个地方开始，你也能做到。 20. 敢于接受有挑战性的任务⭐如果任务没有挑战，它就不会帮助你成长。 21. 项目开始前明确需求⭐在开撸之前，你应该了解验收标准，这将为你节省时间和痛苦。 22. 工欲善其事，必先利其器⭐拥有一套你熟悉的工具，了解哪些工具服务于哪些目的，以及项目何时可以从使用这些工具中获益。 23. 我们需要建设性的批评向信任的同事和朋友寻求建设性的批评，它将帮助你更优秀。 24. 保持开放思维⭐技术在变化，而且变化得很快。不要反对新技术，学习它，然后形成自己的观点。 25. 保持在技术前沿，不要掉队⭐通过关注出版物，博客，播客和科技新闻，及时了解最新的科技新闻。 26. 专注于解决问题⭐锻炼自己解决问题的能力，强大的解决问题的能力能够帮助你应付一切，专注于解决问题的方法。 27. 保持谦虚⭐三人行必有我师，无论你什么头衔，什么公司，都要保持谦逊。 28. 不光要代码写的好，PPT也要讲得好学习如何吸引你的听众，并给出有效的演示。 29. 选型如买菜，也要货比三家⭐给自己更多选择，在开展工作前，调研尽可能多的解决方案。 30. 找到自己的定位⭐科技产业也有很多分类，找到你最感兴趣的领域，并成为一名专家。 31. 养成好习惯⭐试着建立一致的、健康的习惯，比如保持专注，合理安排时间，出席会议，从最重要的任务开始。这可能需要一些时间来适应，但从长远来看是值得的。 32. 学会debug⭐探索浏览器调试器工具。学习使用IDE调试的细节。通过学习最有效的调试问题和跟踪错误的方法，再困难的bug也能搞定。 33. 锻炼你现有的技能⭐并不是说你已经掌握了一项技能就不需要再锻炼它。业精于勤荒于嬉，除非有意识地提高技能，否则技能会随着时间的推移而消失。而这个行业又发展得如此之快，坚持练习是很重要的。从“我一直都是这样做的”的心态中走出来，进入“有没有更好的方法来做这件事”的心态。仅仅是因为你现在拥有六块腹肌，不意味着你就可以每天吃一个🍩。 34. 了解原因⭐有时你必须表达自己的意见，因此了解其背后的原因非常重要。为什么解决方案A比解决方案B更好？提供有效的论据，你的意见将更加可靠。 35. 了解自己的价值技术也是商品，应该得到适当的报酬。了解你所在地区的行业平均水平。如果你赚的钱少了，是时候和你的老板谈谈，追求你应得的。 36. 不要害怕寻求帮助⭐如果你被困在一个问题上，花了太多时间寻找解决方案，是时候寻求帮助了。我们都是人，我们都需要帮助，寻求同事的援助并不可耻。 37. 学会学习⭐人们学习的方式不同，有些人通过视频教程学得最好，有些人通过阅读书籍学得最好。弄清楚你的学习风格，然后努力实践。 38. 与人为善有时你会被要求向同事提供反馈，友善一点，你可以对某位同事不够积极表达看法，而不是出言不逊。 39. 休息一下连续敲8个小时代码几乎是不可能，你很快就会筋疲力尽，犯很多错误。所以设个闹钟来提醒自己停下来休息一下。去散散步，和同事一起喝杯咖啡，远离屏幕会对你的工作效率和质量产生积极的影响。 40. 跟踪你的学习进度学习编程需要时间，当你看不到进展时，你会感到非常沮丧。所以跟踪你的成就和实现目标的进展非常重要。在你的电脑旁边放一个小清单，每次你完成一件事，把它写下来，不管它有多小，最终将会从量变到质变。 41. 不要依赖库和框架⭐掌握一个框架和库不如深入学习这门语言，没有必要一个接一个的学习这些库和框架，但是理解框架和库如何实现可以帮助你写出更简洁强壮的代码。 42. 学会爱上代码审查让别人阅读和分析你的代码可能会让你不安，但是可以提供宝贵的反馈，这会让你成为一个更好的程序员。而且你也应该提高进行良好代码评审的能力。 43. 多方位全面学习学习其他领域的基础知识, 如设计、营销、前端开发或后端开发。它将帮助你成为一个更全面的程序员。 44. 不要选择熟悉的技术，而应该是正确的⭐每个项目都有不同的需求，因此我们必须为这项工作选择合适的工具。尽管选择以前使用过的技术很方便，但是如果它们不适合项目的需要，应该探索其他替代方案。 45. 勇于承担责任⭐所有人都会犯错，在你的职业生涯中，你会犯很多很多的错误。因此，当你犯了错误时，站出来承担责任是很重要的，它将与你的团队成员和管理层建立信任。 46. 检查自己的代码⭐在发起PR请求之前，检查自己的代码，如果这是同事的工作，你会发表什么评论？在请求代码审查之前首先尝试自己诊断问题或错误非常重要，就像考试交卷前应该自己检查一遍。 47. 从失败中吸取教训⭐失败只是没有达到预期的结果，并不一定是件坏事。在我们的职业生涯中，我们会面临很多失败，从失败中学习下次你能做些什么。 48. 正视自己的缺点了解你自己，你的缺点是什么?也许你总是在推送之前忘记更新测试，或者你真的不擅长回复电子邮件。了解你的弱点，这样你就能积极地改善它们。 49. 保持好奇心⭐这个行业在不断发展，所以好奇心很重要。如果你不明白什么，不管是项目需求还是一行代码，大声说出来。没有人会因为你要求说明而批评你，你会因此创造出更好的代码。 50. 不要试图学习一切⭐世界上有无穷无尽的知识宝库，你不可能征服它。选择几个要掌握的主题，其余的就不要管了。你可以获得其他领域的相关知识，但你不可能掌握所有内容。 51. 该舍弃就舍弃仅仅因为你写了一些代码并不意味着你需要对它产生感情。没有人喜欢他们所做的工作被丢弃，但是代码有一个生命周期，所以没有必要一直保留着它。 52. 团队支持优秀的团队相互支持，这为尝试新事物创造了一个安全的空间，而不用担心受到惩罚。 53. 在社区中寻找鼓舞在行业里找几个你钦佩的人。它会激励你继续你的项目或尝试新事物 54. 重视并且珍惜你的工作不管你有多少经验或者你的职位是什么，你的工作都是有价值的，给予它应有的价值。 55. 排除干扰关掉闲置的通知、短信、电子邮件和社交媒体会帮助你集中精力，最大化你的工作日。晚30分钟回复你朋友的信息，他死不了，真有事就打电话了。 56. 乐于助人试着支持你的团队成员，无论是参加一个重要的演讲，还是在他们遇到困难时帮助他们。 57. 不要吝啬你的赞美⭐如果有人做得很好，告诉他们。正面反馈是与团队成员建立信任和帮助他们事业发展的好方法。他们也更有可能帮助你 58. 测试你的代码⭐测试是很重要的。单元测试、回归测试、集成测试、端到端测试。测试你的代码，你的产品将会更加稳定。 59. 制定应对计划当你收到一个新功能需求或bug修改时，先制定应对计划，你需要什么来解决这个问题或开发这个特性？花几分钟来做这件事，也许后面可以为你节省数小时的沮丧。 60. 掌握伪代码伪代码是一项很好的技能，因为它允许你在不浪费时间编写代码的情况下考虑复杂的问题。将一种方法写在纸上，运行不同的测试用例，看看缺陷在哪里。 61. 记录你的成就如果你在工作中获得了嘉奖，把它写下来。如果你开发了一个重要的功能，把它写下来。你会拥有一些积累、沉淀，它将有助于你职业晋升亦或在某一艰难的日子鼓舞你的士气。 62. 学习编程基础⭐学习一些基本的排序和搜索算法以及数据结构。它们与语言无关，可以帮助你跨语言解决问题。 63. 选择长期维护的技术尽管测试最新的技术很有趣，但是选择那些在企业应用程序中易于维护的技术。你们的团队将在未来的岁月里感谢你们。 64. 学习设计模式⭐设计模式是构建代码的有效工具。你可能不是每个项目都需要它们，但是对它们有一个基本的了解将有助于构建更大的应用程序。 65. 化繁为简⭐不要编写复杂的代码来展示你高超的编程技能，而要着眼于可读性和简单性。这将使你的团队成员更容易做出贡献。 66. 还清技术债务技术债务可能会对性能产生巨大影响，所以如果能够重构，就应该重构。（这个建议绝对是好的，但是现实中要面临诸多问题） 67. 优先小版本迭代与其每个月发布一次大规模的升级，不如更频繁地发布较小的变更。这样你不太可能会引入bug和破坏更改。 68. 尽早并经常提交⭐尽早提交和经常提交是确保你的工作保持干净的最好方法，并且还可以减少意外地恢复重要更改的压力。 69. 了解何时寻求帮助你不仅不应该害怕寻求帮助，而且你应该学会什么时候寻求帮助。在寻求帮助之前，你应该试着解决问题，并记录下你尝试的事情。但是当你被一个简单的问题难住一个多小时的时候，代价大于收益，你应该向同事求助。 70. 问一些有效的问题⭐当你问问题的时候，要尽可能的具体，（可以参考github提issue的要求）。 71. 工作中及时寻求反馈你的工作不需要完成就能得到反馈。如果你不确定方向，请一位值得信赖的同事来检查你的解决方案的有效性。 72. 阅读文档⭐文档是关于技术的最纯粹的事实来源，因此学习阅读文档可以快速帮助你成为专家。 73. 尽可能做出各种尝试⭐没有什么能阻止你尝试解决问题的方法，你有什么损失呢？ 74. 在会议上积极发言你的想法和意见是有价值的，所以参加会议将有助于你与你的团队和管理层建立融洽的关系。 75. 跨团队协作如果你有机会和公司里的其他团队一起工作，那就去争取吧。 76. 保持项目热情当你每周工作40个小时时，花时间做你感兴趣的项目是很重要的（72小时的话更要如此）。它们可以帮助你重新找回对编程的热爱，并尝试你在工作中可能无法接触到的新技术。 77. 确定你的职业目标⭐对你的职业生涯有一个理想的轨迹是很重要的。如果你不这样做，你就是在没有目标的情况下射箭。 78. 加入到讨论中来⭐在博客上发表评论，参与Twitter主题，参与社区活动，做一个积极的旁观者会比单纯的旁观学到更多东西。 79. 确定任务优先级学会确定任务的优先顺序将有助于提高您的工作效率，建立一个日常任务和长期任务待办事项列表，并按最重要的顺序排序。 80. 不要忽略细节细节可以在项目中产生很大的影响。 81. 信任你的同事你的同事因为他们的技能而被雇佣，交给他们工作，并相信他们能完成。 82. 学会委托如果你处于领导地位，学习如何有效地委派任务。它会节省你的时间，你不能做所有的事。 83. 不要拿自己和别人比较你唯一应该比较的是昨天的自己。 84. 找到你的盟友学习编程将是一个漫长而不怎么容易的过程，和那些帮助你成长并鼓励你坚持下去的人在一起。 85. 不要想一步登天⭐一开始考虑太多做一个大而全的项目会让你不堪重负。构建时要考虑可伸缩性，但在需要时才开始扩展。这样你就不会用不必要的膨胀来压倒你的团队，而是保持了成长的能力。 86. 衡量性能影响⭐如果你想使用一种很酷的新技术，你应该权衡这样做的性能影响。你能在不影响性能的情况下实现类似的功能吗？如果可以，你可能需要重新考虑你的方法了。 87. 技术歧视不可取⭐不要歧视新技术或新想法，对学习新技能的可能性保持开放的心态，也不要歧视他人，我们都值得尊重。（也不要歧视旧技术，即使现在前端框架盛行，但你也不能说Jquery就没有任何可取之处。） 88. 申请你不能胜任的工作你永远不可能满足工作的所有要求，所以抓住机会申请吧，你有什么损失呢？ 89. 模块化你的代码你可以在一个长文件中编写所有代码，但这是不可维护的。通过模块化，我们确保代码易于理解和测试。 90. 不要只是做代码的搬运工⭐如果你要复制并粘贴Stack Overflow中的解决方案，你应该确切地理解它的作用，有意识地选择要引入的代码。 91. 创造一个舒适的工作环境⭐如果你喜欢你的工作环境和技术设置，你会更有动力去工作，所以还在等什么？ 92. 记住你来自哪里我们都是从同一个地方开始的，随着你的技能和职位的发展，不要忘记你来自哪里，不要膨胀。 93. 试着保持乐观如果出了什么问题，试着乐观一点。明天是新的一天。乐观会帮助你的团队充满活力和精神健康。 94. 不断重新评估你的工作流程⭐仅仅因为某样东西现在有效，并不意味着它永远有效。重新评估你的工作流程，并在必要时做出调整。 95. 学会在家办公如果你有能力在家工作，那就学会有效地在家工作。找一个独立的办公空间，远离干扰。Boneskull写了一篇很棒的关于在家工作的文章，你应该看看。 96. 无障碍代码无障碍不是事后才想到的，也不一定很难，每个人都应该能够使用你的产品。 97. 遵守你的承诺⭐如果你告诉别人你会在某一天完成某件事，要信守承诺。如果你不能在截止日期前完成任务，那就早点说出来。 98. 积极主动如果你有额外的精力，找一个任务来帮助你的团队，他们会很感激你是主动的。 99. 创建一个令人惊叹的作品集一个优秀的作品集让你与众不同，使用它作为展示你的编程和设计技巧的机会！ 100. 记住你喜欢编程的原因⭐你进入这个行业是因为它激发了你的兴趣，如果你感到沮丧和怨恨，休息一下，给自己空间重新点燃你对编程的激情。 101. 分享你的知识⭐如果你学到了一些很酷的东西，不要吝惜分享它，参加当地的技术交流会，在午餐时间教你的同事或学员，分享你的知识可以让更多人受益同时自己也能巩固提高。 最后多加两条： 102. 条适当锻炼和103. 条充足睡眠]]></content>
      <categories>
        <category>译文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS内购相关封装]]></title>
    <url>%2F2019%2F05%2F28%2FiOS%E5%86%85%E8%B4%AD%E7%9B%B8%E5%85%B3%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[将内购相关d功能封装成单例类，直接上代码.h相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import &lt;Foundation/Foundation.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@protocol YYAInAppPurchaseToolDelegate &lt;NSObject&gt;/*** TODO: System error.*/- (void)IAPToolSysWrong;/*** 已刷新可购买商品** @param products 商品数组*/- (void)IAPToolGotProducts:(NSMutableArray *)products;/*** 购买成功** @param productID 购买成功的商品ID*/- (void)IAPToolBoughtProductSuccessedWithProductID:(NSString *)productIDandInfo:(NSDictionary *)infoDic;;/*** 取消购买** @param productID 商品ID*/- (void)IAPToolCanceldWithProductID:(NSString *)productID;/*** 购买成功，开始验证购买** @param productID 商品ID*/- (void)IAPToolBeginCheckingdWithProductID:(NSString *)productID;/*** 重复验证** @param productID 商品ID*/- (void)IAPToolCheckRedundantWithProductID:(NSString *)productID;/*** 验证失败** @param productID 商品ID*/- (void)IAPToolCheckFailedWithProductID:(NSString *)productIDandInfo:(NSData *)infoData;/*** 恢复了已购买的商品（永久性商品）** @param productID 商品ID*/- (void)IAPToolRestoredProductID:(NSString *)productID;@endNS_ASSUME_NONNULL_BEGIN@interface YYAInAppPurchaseTool : NSObjecttypedef void(^BoolBlock)(BOOL successed,BOOL result);typedef void(^DicBlock)(BOOL successed,NSDictionary *result);/*** 代理*/@property(nonatomic,weak) id &lt;YYAInAppPurchaseToolDelegate&gt; delegate;/*** 购买完后是否在iOS端向服务器验证一次,默认为YES*/@property(nonatomic)BOOL CheckAfterPay;/*** 单例** @return YQInAppPurchaseTool*/+(YYAInAppPurchaseTool *)defaultTool;/*** 询问苹果的服务器能够销售哪些商品** @param products 商品ID的数组*/- (void)requestProductsWithProductArray:(NSArray *)products;/*** 用户决定购买商品** @param productID 商品ID*/- (void)buyProduct:(NSString *)productID;/*** 恢复商品（仅限永久有效商品）*/- (void)restorePurchase;@endNS_ASSUME_NONNULL_END .m相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#import &quot;YYAInAppPurchaseTool.h&quot;#ifdef DEBUG#define checkURL @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;#else#define checkURL @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;#endif@interface YYAInAppPurchaseTool ()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;/*** 商品字典*/@property(nonatomic,strong)NSMutableDictionary *productDict;@end@implementation YYAInAppPurchaseToolstatic YYAInAppPurchaseTool *storeTool;/// 单例+ (YYAInAppPurchaseTool *)defaultTool &#123;if(!storeTool)&#123;storeTool = [YYAInAppPurchaseTool new];[storeTool setup];&#125;return storeTool;&#125;#pragma mark 初始化- (void)setup &#123;self.CheckAfterPay = YES;// 设置购买队列的监听器[[SKPaymentQueue defaultQueue] addTransactionObserver:self];&#125;/// 询问苹果的服务器能够销售哪些商品- (void)requestProductsWithProductArray:(NSArray *)products &#123;NSLog(@&quot;开始请求可销售商品&quot;);// 能够销售的商品NSSet *set = [[NSSet alloc] initWithArray:products];// &quot;异步&quot;询问苹果能否销售SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:set];request.delegate = self;// 启动请求[request start];&#125;#pragma mark 获取询问结果，成功采取操作把商品加入可售商品字典里/*** 获取询问结果，成功采取操作把商品加入可售商品字典里** @param request 请求内容* @param response 返回的结果*/- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response &#123;if (self.productDict == nil) &#123;self.productDict = [NSMutableDictionary dictionaryWithCapacity:response.products.count];&#125;NSMutableArray *productArray = [NSMutableArray array];for (SKProduct *product in response.products) &#123;//NSLog(@&quot;%@&quot;, product.productIdentifier);// 填充商品字典[self.productDict setObject:product forKey:product.productIdentifier];[productArray addObject:product];&#125;//通知代理[self.delegate IAPToolGotProducts:productArray];&#125;#pragma mark - 用户决定购买商品/*** 用户决定购买商品** @param productID 商品ID*/- (void)buyProduct:(NSString *)productID &#123;SKProduct *product = self.productDict[productID];// 要购买产品(店员给用户开了个小票)SKPayment *payment = [SKPayment paymentWithProduct:product];// 去收银台排队，准备购买(异步网络)[[SKPaymentQueue defaultQueue] addPayment:payment];&#125;#pragma mark - SKPaymentTransaction Observer#pragma mark 购买队列状态变化,,判断购买状态是否成功/*** 监测购买队列的变化** @param queue 队列* @param transactions 交易*/- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions &#123;// 处理结果for (SKPaymentTransaction *transaction in transactions) &#123;NSLog(@&quot;队列状态变化 %@&quot;, transaction);// 如果小票状态是购买完成if (SKPaymentTransactionStatePurchased == transaction.transactionState) &#123;//NSLog(@&quot;购买完成 %@&quot;, transaction.payment.productIdentifier);if(self.CheckAfterPay)&#123;//需要向苹果服务器验证一下//通知代理[self.delegate IAPToolBeginCheckingdWithProductID:transaction.payment.productIdentifier];// 验证购买凭据[self verifyPruchaseWithID:transaction.payment.productIdentifier];&#125;else&#123;//不需要向苹果服务器验证//通知代理[self.delegate IAPToolBoughtProductSuccessedWithProductID:transaction.payment.productIdentifierandInfo:nil];&#125;// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125; else if (SKPaymentTransactionStateRestored == transaction.transactionState) &#123;//NSLog(@&quot;恢复成功 :%@&quot;, transaction.payment.productIdentifier);// 通知代理[self.delegate IAPToolRestoredProductID:transaction.payment.productIdentifier];// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125; else if (SKPaymentTransactionStateFailed == transaction.transactionState)&#123;// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];//NSLog(@&quot;交易失败&quot;);[self.delegate IAPToolCanceldWithProductID:transaction.payment.productIdentifier];&#125;else if(SKPaymentTransactionStatePurchasing == transaction.transactionState)&#123;NSLog(@&quot;正在购买&quot;);&#125;else&#123;NSLog(@&quot;state:%ld&quot;,(long)transaction.transactionState);NSLog(@&quot;已经购买&quot;);// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125;&#125;&#125;#pragma mark - 恢复商品/*** 恢复商品*/- (void)restorePurchase &#123;// 恢复已经完成的所有交易.（仅限永久有效商品）[[SKPaymentQueue defaultQueue] restoreCompletedTransactions];&#125;#pragma mark 验证购买凭据/*** 验证购买凭据** @param ProductID 商品ID*/- (void)verifyPruchaseWithID:(NSString *)ProductID &#123;// 验证凭据，获取到苹果返回的交易凭据// appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];// 从沙盒中获取到购买凭据NSData *receiptData = [NSData dataWithContentsOfURL:receiptURL];// 发送网络POST请求，对购买凭据进行验证//In the test environment, use https://sandbox.itunes.apple.com/verifyReceipt//In the real environment, use https://buy.itunes.apple.com/verifyReceipt// Create a POST request with the receipt data.NSURL *url = [NSURL URLWithString:checkURL];NSLog(@&quot;checkURL:%@&quot;,checkURL);// 国内访问苹果服务器比较慢，timeoutInterval需要长一点NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:20.0f];request.HTTPMethod = @&quot;POST&quot;;// 在网络中传输数据，大多情况下是传输的字符串而不是二进制数据// 传输的是BASE64编码的字符串/**BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性BASE64是可以编码和解码的*/NSString *encodeStr = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];NSString *payload = [NSString stringWithFormat:@&quot;&#123;\&quot;receipt-data\&quot; : \&quot;%@\&quot;&#125;&quot;, encodeStr];NSData *payloadData = [payload dataUsingEncoding:NSUTF8StringEncoding];request.HTTPBody = payloadData;// 提交验证请求，并获得官方的验证JSON结果NSURLSession *session = [NSURLSession sharedSession];// 4.根据会话对象，创建一个Task任务NSURLSessionDataTask *sessionDataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;NSLog(@&quot;从服务器获取到数据&quot;);NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:(NSJSONReadingMutableLeaves) error:nil];if (dict != nil) &#123;// 验证成功,通知代理// bundle_id&amp;application_version&amp;product_id&amp;transaction_id[self.delegate IAPToolBoughtProductSuccessedWithProductID:ProductIDandInfo:dict];&#125; else &#123;//验证失败,通知代理[self.delegate IAPToolCheckFailedWithProductID:ProductIDandInfo:data];&#125;&#125;];[sessionDataTask resume];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内购</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native开发环境的搭建（Mac）]]></title>
    <url>%2F2019%2F05%2F24%2FReact-Native%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88Mac%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装依赖1.先安装Homebrew（若已安装，可跳过）1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/ 2.安装node和webpack 12brew install nodebrew install webpack 测试node和webpack是否安装成功，可用如下命令进行检测。若本地安装，则会显示对应版本号。12node -vwebpack -v 3.设置国内镜像（常年开vpn的可以忽略）1npm config set disturl https://npm.taobao.org/dist --global 这里出错了，按提示走就可以，复制sudo那一行更改目录权限，再设置国内镜像。 4.安装RN：直接输入npm install -g react-native-cli。会因为权限不够而报错：npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules。所以我们直接输入下面两句话12sudo chown -R $(whoami) /usr/local/*npm install -g yarn react-native-cli 测试是否安装成功：1react-native -v 创建RN项目到本地1.创建RN项目1react-native init AwesomeProject 2.编译并运行 React Native 应用12cd AwesomeProjectreact-native run-ios 提示：如果 run-ios 无法正常运行，请使用 Xcode 运行来查看具体错误（run-ios 的报错没有任何具体信息）。第一次运行会比较慢，需要耐心等待一下 3.修改项目现在你已经成功运行了项目，我们可以开始尝试动手改一改了： 使用你喜欢的编辑器打开App.js并随便改上几行。 在 iOS 模拟器中按下⌘-R就可以刷新 APP并看到你的最新修改！（如果没有反应，请检查模拟器的 Hardware 菜单中，connect hardware keyboard 选项是否选中开启） 大功告成]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS截图那些事]]></title>
    <url>%2F2018%2F09%2F06%2FiOS%E6%88%AA%E5%9B%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[普通view截图12345678910+ (UIImage *)gjj_viewScreenShot:(UIView *)view &#123;UIGraphicsBeginImageContextWithOptions(CGSizeMake(view.frame.size.width, view.frame.size.height ), NO, 0.0);[view.layer renderInContext:UIGraphicsGetCurrentContext()];/// 返回一个基于当前图形上下文的图片UIImage *viewImage = UIGraphicsGetImageFromCurrentImageContext();/// 移除栈顶的基于当前位图的图形上下文UIGraphicsEndImageContext();return viewImage;&#125; tableView、collectionView等scrollView生成长截图实现步骤 保存scrollView截取前的偏移量及Frame 计算出你要截取的长图的高度及宽度，即scrollView的contentSize，将scrollView.frame设成scrollView.contentSize 渲染出scrollView整体（上下文），截取当前scrollView生成Image 恢复scrollView的偏移量及Frame 12345678910111213141516+ (UIImage *)gjj_scrollViewScreenShot:(UIScrollView *)scrollView &#123;UIImage *image = nil;UIGraphicsBeginImageContextWithOptions(scrollView.contentSize, YES, [UIScreen mainScreen].scale);CGPoint saveContentOffset = scrollView.contentOffset;CGRect savedFrame = scrollView.frame;scrollView.contentOffset = CGPointZero;scrollView.frame = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height);[scrollView.layer renderInContext:UIGraphicsGetCurrentContext()];scrollView.layer.contents = nil;image = UIGraphicsGetImageFromCurrentImageContext();scrollView.contentOffset = saveContentOffset;scrollView.frame = savedFrame;UIGraphicsEndImageContext();return image;&#125; webView生成长截图webView和scrollView的截图大同小异 12345678910111213141516+ (UIImage *)gjj_webViewScreenShot:(UIWebView *)webView &#123;UIImage *image = nil;UIGraphicsBeginImageContextWithOptions(webView.scrollView.contentSize, YES, [UIScreen mainScreen].scale);CGPoint saveContentOffset = webView.scrollView.contentOffset;CGRect savedFrame = webView.frame;webView.scrollView.contentOffset = CGPointZero;webView.frame = CGRectMake(0, 0, webView.scrollView.contentSize.width, webView.scrollView.contentSize.height);[webView.layer renderInContext:UIGraphicsGetCurrentContext()];webView.layer.contents = nil;image = UIGraphicsGetImageFromCurrentImageContext();webView.scrollView.contentOffset = saveContentOffset;webView.frame = savedFrame;UIGraphicsEndImageContext();return image;&#125; 图片拼接很多需求是截图附带二维码等进行分享。 123456789101112131415161718192021222324+ (UIImage *)gjj_addHeadImage:(UIImage *)headImage footImage:(UIImage *)footImage toMasterImage:(UIImage *)masterImage &#123;CGSize size;size.width = masterImage.size.width;CGFloat headProportion = !headImage?0:(headImage.size.width / headImage.size.height);CGFloat footProportion = !footImage?0:(footImage.size.width / footImage.size.height);CGFloat headHeight = !headImage? 0:masterImage.size.width/headProportion;CGFloat footHeight = !footImage? 0:footImage.size.width/footProportion;size.height = masterImage.size.height + headHeight + footHeight;UIGraphicsBeginImageContextWithOptions(size, YES, 0.0);if (headImage) &#123;[headImage drawInRect:CGRectMake(0, 0, masterImage.size.width, headHeight)];&#125;[masterImage drawInRect:CGRectMake(0, headHeight, masterImage.size.width, masterImage.size.height)];if (footImage) &#123;[footImage drawInRect:CGRectMake(0, masterImage.size.height + headHeight, masterImage.size.width, footHeight)];&#125;UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();return resultImage;&#125; 添加水印12345678910+ (UIImage *)gjj_addWaterImage:(UIImage *)waterImage toMasterImage:(UIImage *)masterImage waterImageRect:(CGRect)rect &#123;UIGraphicsBeginImageContextWithOptions(masterImage.size, NO, 0);[masterImage drawInRect:CGRectMake(0, 0, masterImage.size.width, masterImage.size.height)];/// 绘制水印图片到当前上下文[waterImage drawInRect:rect];UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return newImage;&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C实现】给出一个字符串，要求将其按照单词顺序进行反转]]></title>
    <url>%2F2018%2F08%2F21%2F%E3%80%90C%E5%AE%9E%E7%8E%B0%E3%80%91%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%A6%81%E6%B1%82%E5%B0%86%E5%85%B6%E6%8C%89%E7%85%A7%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目：给出一个字符串，要求将其按照单词顺序进行反转，比如如果是”the sky is blue”,那么反转之后的结果就是”blue is sky the”。问题分析： 每个单词长度不一致 空格需要特殊处理 使用C语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void swap (char chars[], int p, int q);void reverse (char chars[], int start, int end);void reverseWords(char strings[]);int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;char string[] = &quot;the sky is blue&quot;;reverseWords(string);&#125;return 0;&#125;void swap (char chars[], int p, int q) &#123;char temp = chars[p];chars[p] = chars[q];chars[q] = temp;&#125;void reverse (char chars[], int start, int end) &#123;NSLog(@&quot;%s&quot;,chars);int s = start;int e = end;while (s &lt; e) &#123;swap(chars, s, e);s += 1;e -= 1;&#125;NSLog(@&quot;%s&quot;,chars);&#125;void reverseWords(char strings[]) &#123;if ((int)strlen(strings) == 0) &#123;return;&#125;int start = 0, len = (int)strlen(strings);reverse(strings, 0, len - 1);for (int i = 0 ; i &lt; len; i++) &#123;if ((i == len - 1) || (strings[i + 1] == &apos; &apos;)) &#123;reverse(strings, start, i);start = i + 2;&#125;&#125;NSLog(@&quot;%s&quot;,strings);&#125; 控制台打印：2018-08-14 16:04:22.815076+0800 算法[6268:668783] blue is sky the]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLPreviewController]]></title>
    <url>%2F2018%2F05%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[QLPreviewController在iOS中用于方便预览文件，它支持的文件有： iWork文档 微软Office97以上版本的文档 RTF文档 PDF文件 图片文件 文本文件和CSV文件 使用的时候首先要引用#import &lt;QuickLook/QuickLook.h&gt;。 初始化： 12345_qlPreviewController = [[ QLPreviewController alloc]init]; _qlPreviewController.dataSource = self; _qlPreviewController.delegate = self; [self presentViewController:_qlPreviewController animated:YES completion:nil]; QLPreviewController类似于Tableview的使用方法，也是首先遵循代理和数据源代理。然后实现代理方法，如下： 123456789-(NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller&#123; return 2;&#125;-(id&lt;QLPreviewItem&gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;aa&quot; ofType:@&quot;doc&quot;]; NSURL *myDoucment = [NSURL fileURLWithPath:path]; return myDoucment;&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
  </entry>
</search>
