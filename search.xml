<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gerrit添加SSh key 仍报错 Permission denied (publickey)的问题]]></title>
    <url>%2F2023%2F04%2F18%2FGerrit%E6%B7%BB%E5%8A%A0SSh-key-%E4%BB%8D%E6%8A%A5%E9%94%99-Permission-denied-publickey-%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述升级iMac系统之后，突然使用SSH方式提交Gerrit一直提示Permission denied (publickey)，查看本地SSH key也存在，尝试重新生成SSH key进行重新绑定也是不行，git clone也提示无权限。 问题原因本地OpenSSH的版本号，如果版本≥8.8，就会出现这个问题。可以在终端执行ssh -V查看，发现版本号为9.0 问题解决例如Gerrit SSH地址为ssh://xuefei@gerrit.dev.aicfe.cn:29418配置.ssh目录下的config文件如下：Host gerrit.dev.aicfe.cnHostName gerrit.dev.aicfe.cnUser xuefeiPubkeyAcceptedKeyTypes +ssh-rsaIdentityFile ~/.ssh/id_rsaPort 29418 配置好后，就可以正常提交和拉取了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PMP-项目管理体系-启动过程组]]></title>
    <url>%2F2023%2F04%2F16%2FPMP-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[启动过程组1.1 定义 启动过程组包括定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段的一组过程 目的：协调相关方期望与项目目的，告知相关方项目范围和目标，并商讨他们对项目及相关阶段的参与将如何有助实现其期望。 主要作用：确保只有符合组织战略目标的项目才能立项，以及在项目开始时就认真考虑商业论证、项目效益和相关方。 包含两个过程：4.1制定项目章程和13.1识别相关方 1.2 项目边界 可行性研究约等于商业论证约等于成本效应分析 可交付成果交付：1.客户 2. 发起人 3.最终用户。 转移：1.内部运营 2.外部客户/用户 1.3 4.1制定项目章程 - 《项目章程》1.3.1 理解项目章程 项目章程是由项目启动者或发起人发布的，正式批准项目成立，并授权项目经理使用组织资源开展项目活动的文件。 它记录了关于项目和项目预期交付的产品、服务或成果的高层级信息，例如：项目目的；可测量的项目目标和相关的成功标准；高层级需求；高层级项目描述、边界定义以及主要可交付成果；整体项目风险；总体里程碑进度计划；预先批准的财务资源；关键相关方名单；项目审批要求（例如：用什么标准评价项目成功，由谁对项目成功下结论，由谁来签署项目结束）；项目退出标准（例如：在何种条件下才能关闭或取消项目或阶段）；委派项目经理PM及其职责和职权；发起人或其他批准项目章程的人员姓名和职权。 项目章程确保相关方在总体上就主要可交付成果、里程碑以及每个项目参与者的角色和职责达成共识 1.3.2 项目选择工具 成本效益分析 评分标准未加权模型：打分表， 加权模型：加权模型和未加权模型就是矩阵图，数相加，加权乘以权重之后相加。 圣牛模型：老板说了算 经营需要模型 专家意见模型 比较利益分类模型 1.3.3 成本效益分析1.3.3.1 定义提出若干实现该目标的方案，运用一定的技术方法，计算出每种方案的成本和效益，通过比较方法，并依据一定的原则，选择出最优的决策方案。 1.3.3.2 五种选择方法1.3.3.2.1 净现值（NPV）（Net Present Value） 含义：在项目计算期内，按行业基准折现率或其他设定折现率计算的各年净现金流量现值的代数和。 计算公式： ${NPV} = \sum\frac{CI-CO}{(1+r)^{t}} - 原始投资\ CI：年收益；CO:年支出； r:折现率； t:现金率年份；\frac1{(1+r)^{t}}:折现因子。$ 净现值&gt;=0：方案可行；净现值&lt;0：方案不可行；净现值越大越好 1.3.3.2.2 内部报酬率（IRR）（Internal rate of Return） 含义：项目投资实际可望达到的收益率，是最能使项目的净现值等于零时的折现率，又称为内部收益率。就是NPV=0时的折现率每年的净收益率。 公式：$\sum\frac{CI-CO}{(1+r)^{t}} = {0}$ 选择原则：越大越好 1.3.3.2.3 投资回报率（ROI）（Return on Investment） 含义：通过投资而应返回的价值，它涵盖了企业的获利目标，又称会计收益率、投资利润率 公式：投资回报率（ROI）= 利润或年均利润/投资总额 * 100% 选择原则：越大越好 1.3.3.2.4 收益成本比（BCR）（Benefit Cost Ratio） 含义：项目在计算期内效益流量与费用流量的比率，是经济分析的辅助评价指标。由预期收益除以预期成本所得出的比率（投资1元钱所带来的几元钱的汇报） 公式：效益成本比（BCR）= 现金流入总量/现金流出总量 =&gt; 可以理解为收入/成本 选择原则：BCR=1.0时，项目不赔不赚；BCR&gt;1.0时，比率越高盈利越大；BCR&lt;1.0时，实施该项目会赔钱 2.3.3.2.5 回收期（PBP）（Payback Period） 含义： 根据回收原始投资额所需时间的长短来进行投资决策的方法，也称为偿还期或还本期法。就是回收成本所需要的时间 公式：回收期（PBP）= 原始总投资额/每年相等的净现金流量 选择原则：越短越好 项目计算期：指投资项目从投资建设开始到最终清理结束整个过程的全部时间，即该项目有效持续时间。完整项目计算期包括建设期（s）和经营期（p） 原始投资：企业为使项目完全达到设计生产能力、开展正常经营而投入的全部现实资金，包括固定资产投资、流动资产投资、其他长期资产投资 投资总额：反映项目投资总体规模的价值指标 投资总额 = 原始投资+资本化利息 净现金流量：又称现金净流量，指在项目计算期内各年现金流入量与现金流出量之差。 某年净现金流量=该年现金流入量-该年现金流出量 静态回收期：用投资项目所得的净现金流量来回收原始投资所需的年限 互斥项目：指在多个项目的选择中只能选取一个项目，其他项目必须放弃，即项目之间具有排他性，只能选择一个最优方案。 1.3.4 会议管理1.3.4.1 定义会议管理是采取步骤确保会议有效并高效的达到预期目标 1.3.4.2 步骤 准备并发布会议议程（其中包含会议目标） 确保会议在规定的时间开始和结束 确保适当参与者受邀并出席 切题 处理会议中的期望、问题和冲突 记录所有行动以及所分配的行动责任人☆ 1.4 识别相关方 - 13.1识别相关方1.4.1 相关方登记册相关方登记册是识别相关方过程的主要输出。它记录关于已识别相关方信息，包括（但不限于）： 身份信息：姓名、组织职位、地点、联系方式，以及在项目中扮演的角色。 评估信息：主要需求、期望、影响项目成果的潜力，以及相关方最能影响或冲击的项目生命周期阶段。 相关方分类：用内部或外部，作用、影响、权利或利益，上级、下级、外围或横向，或者项目经理选择的其他分类模型，进行分类的结果 1.4.2 相关方分析 ☆权力利益方格、权利影响方格、作用影响方格 ：权力利益方格是基于相关方的职权级别（权力）、对项目成果的关心程度（利益）、对项目成果的影响能力（影响），或改变项目计划或执行的能力，每一种方格都可用于对相关方进行分类。对于小型项目、相关方与项目的关系很简单的项目，或相关方之间的关系很简单的项目，这些分类模型非常实用。 相关方立方体（综合了权力利益、权利影响、作用影响方格） ☆凸显模型（权利、紧迫性、合法性）：通过评估相关方的权力（职权级别或对项目成果的影像能力）、紧迫性（因时间约束或相关方对项目成果有重大利益诉求而导致需立即加以关注）和合法性（参与的适当性），对相关方进行分类。在凸显模型中，也可以用邻近性取代合法性，一边考察相关方参与项目工作的程度。这种凸显模型适用于复杂的相关方大型社区，或在相关方社区内部存在复杂的关系网络。凸显模型可用于确定已识别相关方的相对重要性。 影响方向（向上、向下、向外、横向） 优先级排序 1.4.3 合同类型 合同类型 适用 总价合同 买方必须准确定义要采购的产品或服务，对采购规范的任何变更都可能增加买方的成本 固定总价合同（Fixed-Price，FFP） 采用总价合同买方必须定义要采购的产品或服务，虽然允许范围变更，但范围变更通常会导致合同价格提高。 总价加激励费合同（Fixed Price Incentive Fee，FPIF） 设置一个价格上限，卖方必须完成工作并且要承担高于上限的全部成本。 总价加经济价格调整合同（Fixed Price with Economic Price Adjustment，FP-EPA） 持续时间较长的合同，允许根据条件变化以事前确定的方式对合同价格进行最终调整。 成本补偿合同 工作范围无法准确定义，项目工作存在较大风险，以便重新安排卖方的工作。 成本加奖励费合同（Cost Plus Award Fee，CPAF） 适用于成果评价标准不易或无法量化的项目，如管理咨询项目等，支付的奖励费用完全由买方主观判断决定，卖方无权申诉。 成本加激励费合同（Cost Plus Incentive Fee，CPIF） 基于卖方的实际成本按一定的比例分担超过或低于目标成本的部分，便于卖方重视控制成本。 成本加固定费合同（Cost Plus Fixed Fee，CPFF） 固定费只能针对已完成的工作，不因卖方的绩效而变化，范围发生变化才可考虑费用的改变。 工料合同（T&amp;M） 增加人员、聘请专家、寻求外部支持，可规定价格和时间限制，防止成本无限增加。 这类合同范围不太明确，需要外包人。 对于卖方风险：固定总价合同&gt;总价加激励费合同&gt;总价加经济价格调整合同&gt;成本加奖励费合同&gt;成本加激励费合同&gt;成本加固定费合同 对于买方风险：固定总价合同&lt;总价加激励费合同&lt;总价加经济价格调整合同&lt;成本加奖励费合同&lt;成本加激励费合同&lt;成本加固定费合同 工料合同风险不确定，有较大灵活性。]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PMP-项目管理“十五至尊图”]]></title>
    <url>%2F2023%2F04%2F16%2FPMP-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E2%80%9C%E5%8D%81%E4%BA%94%E8%87%B3%E5%B0%8A%E5%9B%BE%E2%80%9D%2F</url>
    <content type="text"><![CDATA[项目管理“十五至尊图”☆☆☆ 知识领域 项目管理过程组 启动过程组 规划过程组 执行过程组 监控过程组 收尾过程组 4.项目整合管理 4.1制定项目章程 4.2制定项目管理计划 4.3指导与管理项目工作 4.4管理项目知识 4.5监控项目工作 4.6实施整体变更控制 4.7结束项目或阶段 5.项目范围管理 5.1规范范围管理 5.2收集需求 5.3定义范围 5.4创建WBS 5.5确认范围 5.6控制范围 6.项目进度管理 6.1规划进度管理 6.2定义活动 6.3排列活动顺序 6.4估算活动持续时间 6.5制定进度计划 6.6控制进度 7.项目成本管理 7.1规划成本管理 7.2估算成本 7.3制定预算 7.4控制成本 8.项目质量管理 8.1规划质量管理 8.2管理质量 8.3控制质量 9.项目资源管理 9.1规划资源管理 9.2估算活动资源 9.3获取资源 9.4建设团 9.5管理团队 9.6控制资源 10.项目沟通管理 10.1规划沟通管理 10.2沟通管理 10.3监督沟通 11.项目风险管理 11.1规划风险管理 11.2识别风险 11.3实施定性风险分析 11.4实施定量风险分析 11.5规划风险应对 11.6实施风险应对 11.7监督风险 12.项目采购管理 12.1规划采购管理 12.2实施采购 12.3控制采购 13.项目相关方管理 13.1识别相关方 13.2规划相关方管理 13.3管理相关方参与 13.4监督相关方参与]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PMP-项目管理概述]]></title>
    <url>%2F2023%2F04%2F06%2FPMP-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1. 项目1.1 项目定义 项目是为创造独特的产品、服务或成果而进行的临时性工作。 1.1.1 项目的特点 临时性 - 是指项目有明确的起点和终点 独特性 - 独特的产品、服务或成果 渐进明细 - 越来清楚 项目驱动变革 - 从商业角度看，项目旨在推动组织从一个状态转到另一个状态，从而达到特定目标。从项目开始之前，通常将此时的组织描述为“当前状态”。项目驱动变革是为了获得期望的结果，即“将来状态”。有些项目可能会创造一个过渡状态，即由多个步骤组成的连续区间，以过渡到将来状态。通过成功完成项目，组织可以实现将来状态并达成特定目标。 1.2 项目创造商业价值PMI将商业价值定义为从商业运作中获得的可量化净效益。效益以有形的、无形的或两者兼有之。有形效益的例子包括：货币资产；股东权益；公共事业；固定设施；工具；市场份额。无形效益的例子包括：商誉；品牌认知度；公共利益；商标；战略一致性；声誉。 1.3 项目启动与终止1.3.1 项目启动背景 符合法规、法律或社会要求 满足相关方（也指干系人或stakeholder利害关系者）的要求或请求 执行、变更业务或技术战略 创造、改进或修复产品、过程或服务 =&gt; 可交付成果 1.3.2 项目结束条件 达成项目目标 不会或不能达到目标 项目资金缺乏或没有可分配资金 项目需求不复存在 无法获得所需人力或物力资源 出于法律或便利原因而终止项目 注：项目结束要进行：1. 项目成果移交 2. 调查失败原因 1.4 项目与运营的比较 区别分类 区别点 项目 运营 工作性质与内容 时效性 一次性 持续不断 频率特征 临时性 重复性 工作内容 基本都是创新性工作 经营、很少创新 工作环境 工作环境 相对开放、不确定 相对封闭、稳定 组织与管理 负责人 项目经理 职能经理（FM）/运营经理 实施团队 项目团队 职能部门、产品线 组织结构 相对变化、临时 相对不变 2. 项目管理2.1 定义 项目管理就是将知识、技能、工具与技术应用于项目活动，以产出可交付成果及达到项目目标，项目成功是在竞争性制约因素下实现预期的商业价值。 在PMOK中包含十大知识领域（整合管理、范围管理、进度管理、成本管理、质量管理、资源管理、沟通管理、风险管理、采购管理、相关方管理）和五大管理过程组（启动、规划、执行、监控、收尾）以及49个子过程。 生命周期阶段（有时间顺序）：1.启动项目 2.组织与准备 3.执行项目工作 4.结束项目 2.2 项目管理的重要性 有效的项目管理能够帮助个人、群体以及公共和私人组织：达成业务目标； 满足相关方的期望 提高可预测性 提高成功的概率 在适当的时间交付正确的产品 解决问题和争议 及时应对风险 优化组织资源的使用 识别、挽救或终止失败项目 管理制约因素（例如范围、进度、质量、进度、成本、资源） 平衡制约因素对项目的影响（例如范围扩大可能会增加成本或延长进度） 以更好的方式管理变更 2.2.1 项目管理不善或缺乏项目管理可能会导致： 项目管理不善或缺乏项目管理可能会导致： 超过时限 成本超支 质量低劣 返工 项目范围扩大失控 组织声誉受损 相关方不满意 正在实施的项目无法达成目标 2.3 生命周期2.3.1 项目生命周期的特征 预测型生命周期，在生命周期的早期阶段确定项目范围、时间和成本。对任何范围的变更都要进行仔细管理。预测型生命周期也称为瀑布型生命周期。 迭代型生命周期，项目范围通常于项目生命周期的的早期确定，但时间及成本估算将伴随着项目团队对产品理解的不断深入而定期修改。迭代方法是通过一系列重复的循环活动来开发产品，而增量方法是渐进的增加产品的功能。 增量型生命周期是通过在预定时间区间内渐进增加产品功能的一些列迭代来产出可交付成果。只有在最后一次迭代之后，可交付成果具有了必要和足够的能力，才能视为完整的。 适应型生命周期属于敏捷型、迭代型和增量型。详细范围在迭代开始之前就得到了定义和批准，适应型生命周期也称为敏捷或变更驱动型生命周期。 混合型生命周期是预测型生命周期和适应型生命周期的组合。充分了解或有确定需求的项目要素遵循预测型开发生命周期，而仍在发展中的要素遵循适应型开发生命周期。 方法 需求 活动 交付 目标 预测型 固定 整个项目仅执行一次 一次交付 管理成本 迭代型 动态 反复执行直至修正 一次交付 解决方案的正确性 增量型 动态 对给定增量执行一次 频繁小规模交付 速度 敏捷型 动态 反复执行直至修正 频繁小规模交付 通过频繁小规模交付和反馈实现的客户价值 混合型 结合了敏捷和预测的方法；混合型生命周期作为过渡策略；混合敏捷方法 2.3.2 预测型需求评估与关键业务/项目文件的相互关系 项目前期准备：时间表（这里指的粗时间）；需求评估（粗需求）；商业论证做出效益管理计划。 开始项目（启动）：商业论证基于合同进行指定项目章程，正式任命项目管理PM。 开启动大会 组织与准备：指定项目管理计划（详细）=&gt; 12子计划（制度）+ 3基准（范围、成本、进度/质量标准） kickoff启动会 执行项目工作：100%原则，只干计划里面的活，其他走变更 产生可交付成果 结束项目 移交可交付成果，总结经验教训 2.4 项目目标2.4.1 smart原则 S（specific）明确的 M（measurable）可测量的 A（attainable）可实现的 R（rewarding）相关联的 ①目标和公司战略相关联②大目标分为各个子目标，各个子目标有关联性，协同资源 T（time-based）有时限的 2.5 项目成功标准 满足项目管理测量指标 完成项目效益管理计划 达到商业论证中记录的已商定的财务测量指标（净现值NPV、投资回报率ROI、内部报酬率IRR、回收期PBP、效益成本比率BCR） 相关方满意 达到组织战略目标 其他成功标准或准则，例如过程产出率 2.6 项目运行环境2.6.1 事业环境因素2.6.1.1 内部因素（限制性条件/制约因素） 组织文化、结构和治理（例如包括愿景、使命、价值观、信念、文化规范、领导风格、等级制度和职权关系、组织风格、道德和行为规范） 设施和资源的地理分布 基础设施 信息技术软件 资源可用性 员工能力 2.6.1.2 外部因素 市场条件 社会和文化影响与问题 法律限制 商业数据库 学术研究 政府或行业标准 财务考虑因素 物理环境因素 2.6.2 组织过程资产2.6.2.1 过程、政策和程序 指南和标准 特定的组织标准 产品和项目生命周期 程序、模板 预先批准的供应商清单 各种合同协议类型 2.6.2.2 组织知识库 配置管理知识库 历史信息与经验教训知识库 测量与缺陷管理数据库 财务数据库 以往的项目档案 知识管理DIKW模型：data 数据 information 工作绩效信息 knowledge 知识（沉淀与分享） wisdom 智慧 2.7 项目、项目集及项目组合管理之间的比较 组织项目管理 项目 项目集 项目组合 定义 项目是为创造独特的产品、服务或成果而进行的临时性工作 项目集是一组互相关联且被协调管理的项目、子项目集和项目集活动，以便获得分别管理所无法获得的利益 项目组合是为实现战略目标而组合在一起的项目、项目集、子项目组合和运营工作的集合 范围 项目具有明确的目标。范围在整个项目生命周期中是渐进明细的。 项目集的范围包括其项目集组件的范围。项目集通过确保各项目集组件的输出和成果协调互补，为组织带来效益。 项目组合组织范围随着组织战略目标的变化而变化。 变更 项目经理对变更和实施过程做出预判，实现对变更的管理和控制。 项目集的管理方法是随着项目集各组件成果和/或输出的交付，在必要是接受和适应变更，优化效益实现。 项目组合经理持续监督更广泛内外部环境的变更。 规划 在整个项目生命周期中，项目经理渐进明细高层级的信息，将其转化为详细的计划。 项目集的管理利用高层级的计划，跟踪项目集组件的依赖关系和进展。项目集计划也用于在组件层级指导规划。 项目组合经理建立并维护与总体项目组合有关的必要过程和沟通。 管理 项目经理为实现项目目标而管理项目团队。 项目集由项目经理管理，其通过协调项目集组件的活动，确保项目集收益预期实现。 项目组合经理可管理或协调项目组合管理人员或对总体项目组合负有报告职责的项目集和项目人员。 监督 项目经理监控项目开展中生产产品、提供服务或成果的工作。 项目集经理监督项目集组件的进展，确保整体目标、进度计划、预算和项目集效益的实现， 项目组合经理监督战略变更以及总体资源分配、绩效成果和项目组合风险。 成功 成功通过产品和项目的质量、时间表、预算的依从性以及客户满意度水平进行衡量。 项目集的成功通过项目集向项目组织交付预期效益的能力以及项目集交付所述效益的效率和效果进行衡量。 成功通过项目组合的总体投资效果和实现的效益进行衡量。 2.8 PMO（项目组合、项目集或项目管理办公室）项目管理办公室（PMO）是对与项目有关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织结构。关键PMO的能力：培养以交付和成果为导向的能力、保持“全局”观、持续改进、知识转移和变革管理。 2.9 组织结构 组织结构类型 项目特征 工作组安排人： 项目经理批准 项目经理角色 资源可用性 项目预算管理人是谁？ 项目管理人员 系统型或简单型 灵活；人员并肩工作 极少或无 兼职；工作角色（如协调员）指定与否不限 极少或无 负责人或操作员 极少或无 职能（集中式） 正在进行的工作（如设计、制造） 极少或无 兼职；工作角色（如协调员）指定与否不限 极少或无 职能经理 兼职 多部门（职能可复制，各部门几乎不会集中） 其中之一；产品；生产过程；项目组合；项目集；地理区域；客户类型 极少或无 兼职；工作角色（如协调员）指定与否不限 极少或无 职能经理 兼职 矩阵-强 按工作职能，项目经理作为一个职能 中到高 全职指定 工作角色 中到高 项目经理 全职 矩阵-弱 工作职能 低 兼职；作为另一项工作的组成部分，并非指定工作角色（如协调员） 低 职能经理 兼职 矩阵-均衡 工作职能 低到中 兼职；作为一种技能的嵌入职能，不可以是指定工作角色（如协调员） 低到中 混合 兼职 项目导向（复合、混合） 项目 高到几乎全部 全部指定工作角色 高到几乎全部 项目经理 全职 虚拟 网络架构，带有与其他人联系的节点 低到中 全职或兼职 低到中 混合 可为全职或兼职 混合型 其他类型的混合 混合 混合 混合 混合 混合 PMO 其他类型的混合 高到几乎全部 全职指定工作角色 高到几乎全部 项目经理 全职 2.10 组织级项目管理（OPM）和战略实现战略目标而整合项目组合、项目集和项目管理与组织驱动因素的框架。 确保组织展开正确的项目并合适的分配关键资源 确保组织的各个层级都了解组织的战略意愿、支持意愿的举措、目标以及交付成果。 2.10.1 项目、组织与战略规划SWOT矩阵 外部：机会与威胁 内部优势与劣势 2.11 相关方/干系人 供应商、客户、最终用户、监管机构 治理机构、项目管理办公室（PMO）、指导委员会 项目经理（PM）、项目管理团队、项目团队、执行团队 法约尔管理五项基本职能：组织、计划、协调、控制、领导 2.12PM能力模型 项目管理专业技能：管事（工具/方法）。与项目、项目集合项目组合管理特定领域相关的知识、技能和行为，即角色履行的技术方面。 领导力：管人的放法。指导、激励和带领团队所需的知识、技能和行为，可帮助组织达成业务目标。 战略和商务管理：关于行业和组织的知识和专业技能，有助于提高绩效并取得更好的业务成果。 工作方式：完成工作的方式选择 商业敏锐度：理解商业场景 影响力技能：驱动变革 2.13 领导力风格 放任型领导（例：允许团队自主决策和设定目标） 交易型领导（例：关注目标、反馈和；成就以确定奖励，例外管理） 服务型领导（例：做出服务承诺，处处先为他人着想；关注他人的成长、学习、发展、自主性和福祉；关注人际关系、团体与合作；服务优先于领导） 变革型领导（例：通过理想化特质和行为 、鼓舞性激励、促进创新和创造，以及个人关怀提高追随者的能力） 魅力型领导（例：能够激励他人；精神饱满、热情洋溢、充满自信；说服力强） 交互型领导（例：结合了交易型、变革型和魅力型领导的特点） 2.14 组织变革2.14.1 科特八步变更模型 Increase Urgency 增加紧迫感 Build the guiding team 建立指导团队 Get the right vision 获得正确愿景 Communicate for buy-in 沟通 Empower action 授权 Create short-term wins 创造短期胜利 Don’t let up 不要放松 Make it stick 坚持下去 2.14.2 1-3步 Creating a climate for change 根据项目特点快速反应组织变革 项目运行方式对齐变革内容 成立专门团队应对组织变革对项目带来的影响 2.14.3 4-6步 Engaging and enabling the whole organization 理清沟通渠道，以便重要信息高度可见 认可奖励成就，激励员工 避免同时启动太多项目，寻找低成本果实 2.14.4 7-8步 Implementing and sustaining change 变革需嵌入组织文化中 通过培训和指导加强新文化 2.15 项目经理的人际关系影响 法定权（Legitimate power：Delegated） - 有获得支持的能力，因为项目职员认为项目经理被正式授予了发号施令 奖赏权（Reward power） - 有获得支持的能力，因为项目职员认为项目经理有能力直接或间接的分发宝贵的组织酬劳 处罚权（Penalty power） - 有获得支持的能力，因为项目职员认为项目经理有能力直接或间接的执行他们力图避免的处罚 专家权（Expert power） - 有获得支持的能力，因为项目职员认为项目经理拥有专门的知识或技能 影响力（Referent power）- 有获得支持的能力，因为项目职员个人对项目经理感兴趣 2.16 项目合规 合规 - 依法合规经营简称合规，是指公司经营活动（包括公司行为和公司职工执行行为）遵守有关法律、法规和公司有关管理制度 合规管理 - 是指为有效识别和防控合规风险，提高全员合规意识而开展的各项管理活动 合规风险 - 是指因公司经营活动违反法律、法规和公司有关管理制度，指使公司受到处罚、财产损失和声誉损失的风险]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Extension断点调试]]></title>
    <url>%2F2022%2F02%2F09%2FiOS-Extension%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[以Broadcast Upload Extension为例。 选中host APP target，run。 Debug -&gt; Attach to process by pID or name：XXX(GDTScreenShareExtension – 这里输入你的extension APP name) 这样控制台就可以断点调试 并 log相关信息了]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 消息转发篇(Message Forwarding) (消息机制)]]></title>
    <url>%2F2022%2F01%2F22%2FiOS-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E7%AF%87-Message-Forwarding-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[OC的方法与消息 方法：与一个类相关的一段实际代码，并给出一个特定的名字。 消息：发送给对象的名称和一组参数。示例：向0x12345678对象发送meaning并且没有参数。 选择器：表示消息或方法名称的一种特殊方式，表示为类型SEL。选择器本质上就是不透明的字符串，它们被管理，因此可以使用简单的指针相等来比较它们，从而提高速度。（实现可能会有所不同，但这基本上是他们在外部看起来的样子。）例如：@selector(meaning) 消息发送：接收信息并查找和执行适当方法的过程。 方法与消息发送消息在OC中方法调用是一个消息发送的过程。OC方法最终被生成为C函数，并带有一些额外的参数。这个C函数objc_msgSend就负责消息发送。 123OBJC_EXPORT id _Nullableobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 可以看到传入的是一个objc_super结构体,结构如下： 1234567struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; __unsafe_unretained _Nonnull Class super_class; /* super_class is the first class to search */&#125;; receiver：消息接收者，是当前classsuper_class ：父类，从父类开始寻找方法，而略过当前类所以 调用[super xxxx] 并不是说父类来调用方法，只是从父类开始寻找方法，然后发送到当前class,最终作用对象,还是当前class 。 消息发送的主要步骤 先在cache中查找imp,找到了返回imp 在当前class的method list中查找有无imp , 在class的方法列表methods中，根据SEL查找对应的imp 找到了 ,将imp存储到当前class 的cache中 在class的所有super classes中查找imp（先看Super class的cache，再看super class的方法列表） 找到了，同3 均未找到imp,进入动态方法解析流程resolveMethod 消息转发没有方法的实现，程序会在运行时挂掉并抛出 unrecognized selector sent to … 的异常。但在异常抛出前，Objective-C 的运行时会给你三次拯救程序的机会： Method resolution Fast forwarding Normal forwarding 动态方法解析: Method Resolution首先，Objective-C 运行时会调用以下方法，让你有机会提供一个函数实现。如果你添加了函数并返回 YES， 那运行时系统就会重新启动一次消息发送的过程。 12+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;&#125; (实例方法)+ (BOOL)resolveClassMethod:(SEL)sel &#123;&#125; (类方法) 可以以下实现： 12345678910111213void eatMethod(id obj, SEL _cmd) &#123; NSLog(@"eat...");&#125;+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if(aSEL == @selector(eat:))&#123; class_addMethod([self class], aSEL, (IMP)eatMethod, "v@:"); return YES; &#125; return [super resolveInstanceMethod];&#125; 我们只需要在 resolveInstanceMethod: 方法中，利用 class_addMethod 方法，将未实现的 eatMethod：绑定到 eatMethod 上就能完成转发，最后返回 YES。 这里第一字符v代表函数返回类型void，第二个字符@代表self的类型id，第三个字符:代表_cmd的类型SEL。官方地址 快速转发: Fast Rorwarding1- (id)forwardingTargetForSelector:(SEL)aSelector &#123;&#125; 消息转发机制执行前，runtime系统允许我们替换消息的接收者为其他对象。通过上面方法。如果此方法返回的是nil 或者self,则会进入消息转发机制（- (void)forwardInvocation:(NSInvocation *)invocation），否则将会向返回的对象重新发送消息。 相关实现 123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(eat:))&#123; return [[CatClass alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 完整消息转发: Normal Forwarding12- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;&#125; 第一个要求返回一个方法签名，第二个方法转发具体的实现。二者相互依赖，只有返回了正确的方法签名，才会执行第二个方法。 forwardInvocation:方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的消息对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的处理掉某些消息，因此没有响应也不会报错。例如：我们可以为了避免直接闪退，可以当消息没法处理时在这个方法中给用户一个提示，也不失为一种友好的用户体验。 其中，参数invocation是从哪来的？在forwardInvocation:消息发送前，runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。所以重写forwardInvocation:的同时也要重写methodSignatureForSelector:方法，否则会抛出异常。当一个对象由于没有相应的方法实现而无法响应某个消息时，运行时系统将通过forwardInvocation:消息通知该对象。每个对象都继承了forwardInvocation:方法，我们可以将消息转发给其它的对象。 相关实现： 1234567891011121314151617181920- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored "-Wundeclared-selector" if (aSelector == @selector(eat:)) &#123; #pragma clang diagnostic pop return [NSMethodSignature signatureWithObjCTypes:"v@:@"];&#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; Person *person = [Person new]; Animal *animal = [Animal new]; if ([person respondsToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:person]; &#125; if ([animal respondsToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:animal]; &#125;&#125; 如果三次都没有处理，就会抛出异常 1unrecognized selector sent to instance 0x6d9f817072b1 模拟多继承转发和继承相似，可用于为OC编程添加一些多继承的效果，一个对象把消息转发出去，就好像他把另一个对象中放法接过来或者“继承”一样。消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。 相关代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface GDTMultipleDelegateProxy : NSObject+ (instancetype)share;/// 把目标类添加到管理类里面- (void)addTarget:(id)target protocol:(id)protocol;/// 移除某个目标类- (void)removeProtocol:(id)protocol;/// 移除所有目标类- (void)removeAll;@endNS_ASSUME_NONNULL_END#import "GDTMultipleDelegateProxy.h"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@interface GDTMultipleDelegateProxy ()@property (nonatomic, strong) NSMutableDictionary *refTargets;@end@implementation GDTMultipleDelegateProxystatic GDTMultipleDelegateProxy *manager = nil;+ (instancetype)share &#123; if (!manager) &#123; manager = [[GDTMultipleDelegateProxy alloc] init]; &#125; return manager;&#125;- (void)addTarget:(id)target protocol:(id)protocol &#123; if (![self.refTargets.allKeys containsObject:protocol]) &#123; NSPointerArray *targets = [NSPointerArray weakObjectsPointerArray]; [targets addPointer:(__bridge void * _Nullable)(target)]; [self.refTargets setObject:targets forKey:protocol]; &#125; else &#123; NSPointerArray *targets = [self.refTargets objectForKey:protocol]; if ([targets.allObjects containsObject:target]) &#123;return;&#125; [targets addPointer:(__bridge void * _Nullable)(target)]; &#125;&#125;/// 方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *sig = [super methodSignatureForSelector:aSelector]; if (!sig) &#123; for (id key in self.refTargets.allKeys) &#123; NSPointerArray *targets = [self.refTargets objectForKey:key]; for (id obj in targets) &#123; if ((sig = [obj methodSignatureForSelector:aSelector])) &#123; break; &#125; &#125; &#125; &#125; return sig;&#125;/// 消息转发- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; for (NSString *key in self.refTargets.allKeys) &#123; NSPointerArray *targets = [self.refTargets objectForKey:key]; const char *name = [key UTF8String]; Protocol *protocol = objc_getProtocol(name); NSAssert(protocol!=nil, @"不存在的协议"); struct objc_method_description protocol_method_description = protocol_getMethodDescription(protocol, anInvocation.selector, NO, YES); NSLog(@"===%@==%s=",NSStringFromSelector(protocol_method_description.name),protocol_method_description.types); if (protocol_method_description.name != nil) &#123; for (id obj in targets) &#123; if ([obj respondsToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:obj]; &#125; &#125; &#125; &#125;&#125;- (void)removeProtocol:(id)protocol &#123; if ([self.refTargets.allKeys containsObject:protocol]) &#123; [_refTargets removeObjectForKey:protocol]; &#125;&#125;- (void)removeAll &#123; [self.refTargets removeAllObjects];&#125;/// 判断目标类是否实现该协议- (BOOL)respondsToSelector:(SEL)aSelector &#123; if ([super respondsToSelector:aSelector]) &#123; return YES; &#125; for (id key in self.refTargets.allKeys) &#123; NSPointerArray *targets = [self.refTargets objectForKey:key]; for (id obj in targets) &#123; if ([obj respondsToSelector:aSelector]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;- (NSMutableDictionary *)refTargets &#123; if (!_refTargets) &#123; _refTargets = [NSMutableDictionary dictionary]; &#125; return _refTargets;&#125;- (Class)getMeterClassObjc:(id)objc &#123; return object_getClass(objc);&#125;//给objc的deallocz转发一个新方法- (void)cy_dealloc&#123; NSLog(@"=====%s====",__func__);&#125;static void cy_dealloc(id self ,SEL _cmd)&#123; NSLog(@"====%s=%@=",__func__,self);&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 15 适配手册]]></title>
    <url>%2F2022%2F01%2F15%2FiOS-15-%E9%80%82%E9%85%8D%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[NavigationBar 颜色及背景失效iOS 15上发现，指定的背景色失效了，但滚动控制器的视图时，导航条的背景又出现了。 As of iOS 15, UINavigationBar, UIToolbar, and UITabBar will use their scrollEdgeAppearance when your view controller’s associated scroll view is at the appropriate edge (or always if you don’t have a UIScrollView in your hierarchy, more on that below).从 iOS 15 开始，UINavigationBar、UIToolbar 和 UITabBar 将在您的视图控制器的关联滚动视图位于适当的边缘时使用它们的 scrollEdgeAppearance（或者总是如果您的层次结构中没有 UIScrollView，更多内容见下文）。 You must adopt the UIBarAppearance APIs (available since iOS 13, specializations for each bar type) to customize this behavior. UIToolbar and UITabBar add scrollEdgeAppearance properties for this purpose in iOS 15.您必须采用 UIBarAppearance API（自 iOS 13 起可用，针对每种条形类型进行了专门化）来自定义此行为。 UIToolbar 和 UITabBar 为此在 iOS 15 中添加了 scrollEdgeAppearance 属性。 相关修改如下： 12345678910111213141516if (@available(iOS 13.0, *)) &#123; UINavigationBarAppearance *appearance = [[self.navigationBar standardAppearance] copy];; appearance.backgroundImage = [self imageFromLayer:gradientLayer]; appearance.titleTextAttributes = @&#123;NSFontAttributeName: [GDDConfig sharedInstance].defaultConfig.navTitleFont, NSForegroundColorAttributeName: [GDDConfig sharedInstance].defaultConfig.navTitleColor&#125;; self.navigationBar.standardAppearance = appearance; /// 根据苹果的注释，如果scrollEdgeAppearance为nil，会默认使用standardAppearance啊。但在 iOS 15 中，必须同时指定standardAppearance和scrollEdgeAppearance才可以。 self.navigationBar.scrollEdgeAppearance = appearance; self.navigationBar.tintColor = [GDDConfig sharedInstance].defaultConfig.navTitleColor;; &#125; else &#123; self.navigationBar.tintColor = [GDDConfig sharedInstance].defaultConfig.navTitleColor; self.navigationBar.titleTextAttributes = @&#123;NSFontAttributeName: [GDDConfig sharedInstance].defaultConfig.navTitleFont, NSForegroundColorAttributeName: [GDDConfig sharedInstance].defaultConfig.navTitleColor&#125;; [self.navigationBar setBackgroundImage:[self imageFromLayer:gradientLayer] forBarMetrics:UIBarMetricsDefault]; &#125; UITabBar 背景图失效UITabBar之前设置的背景图片，老版本可以，iOS 15上表现为空白。 新的API： 1@property (nonatomic, readwrite, copy, nullable) UITabBarAppearance *scrollEdgeAppearance; //ios 15.0. 相关代码修改如下： 123456789101112131415UIImage *img = [UIImage imageNamed:@"image"];if (@available(iOS 13.0, *)) &#123; UITabBarAppearance *appearance = [[tabBar standardAppearance] copy]; appearance.backgroundImage = img; appearance.backgroundImageContentMode = UIViewContentModeScaleToFill; self.tabBar.standardAppearance = appearance; if (@available(iOS 15.0, *)) &#123; self.tabBar.scrollEdgeAppearance = appearance; &#125; else &#123; // Fallback on earlier versions &#125;&#125; else &#123; // Fallback on earlier versions [self.tabBar setBackgroundImage:[img imageWithRenderingMode:(UIImageRenderingModeAlwaysOriginal)]];&#125; UITabBarItem 文字颜色失效新版本中UITabBarItem文字颜色的修改不起作用。 兼容新的 API ： 1@property (nonatomic, readwrite, copy, nullable) UITabBarAppearance *scrollEdgeAppearance; //ios 15.0. 相关代码修改 1234567891011121314151617if (@available(iOS 13.0, *)) &#123; UITabBarAppearance *appearance = [[self.tabBar standardAppearance] copy]; appearance.backgroundColor = [UIColor whiteColor]; UITabBarItemAppearance *itemAppearance = [[UITabBarItemAppearance alloc] init]; itemAppearance.selected.titleTextAttributes = @&#123;NSForegroundColorAttributeName: [GDDConfig sharedInstance].defaultConfig.highlightColor&#125;; appearance.stackedLayoutAppearance = itemAppearance; self.tabBar.standardAppearance = appearance; if (@available(iOS 15.0, *)) &#123; self.tabBar.scrollEdgeAppearance = appearance; &#125; else &#123; // Fallback on earlier versions &#125; &#125; else &#123; // Fallback on earlier versions self.tabBar.tintColor = [GDDConfig sharedInstance].defaultConfig.highlightColor; &#125; UITableViewiOS15 UITableView新增了一个新属性：sectionHeaderTopPadding，默认值为automaticDimension，此属性会给每一个 section header 增加一个默认高度，当我们使用UITableViewStylePlain 初始化tableView的时候，系统默认给 section header 增高了22像素。解决方案是调整sectionHeaderTopPadding属性设置，有需要隐藏头部设置为0即可： 123if (@available(iOS 15.0, *)) &#123; self.tableView.sectionHeaderTopPadding = 0;&#125; ## UIButtonUIButton支持更多配置。UIButton.Configuration是一个新的结构体，它指定按钮及其内容的外观和行为。它有许多与按钮外观和内容相关的属性，如cornerStyle、baseForegroundColor、baseBackgroundColor、buttonSize、title、image、subtitle、titlePadding、imagePadding、contentInsets、imagePlacement等。 相关代码： 1234567891011121314UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];button.backgroundColor = [UIColor greenColor];if (@available(iOS 15.0, *)) &#123; UIButtonConfiguration *conf = [UIButtonConfiguration tintedButtonConfiguration]; conf.cornerStyle = UIButtonConfigurationCornerStyleMedium; [conf setImagePadding:5]; [conf setTitle:@"大标题"]; [conf setSubtitle:@"副标题"]; [conf setImage:[UIImage imageNamed:@"btnImage.png"]]; conf.imagePlacement = NSDirectionalRectEdgeLeading; button.configuration = conf;&#125; else &#123; // Fallback on earlier versions&#125; ## UIImage图片的尺寸变换,相关代码 12345678910111213141516UIImage *modeImg = [UIImage imageNamed:@"bgImage.png"];NSLog(@"图片原尺寸%@", NSStringFromCGSize(modeImg.size));if (@available(iOS 15.0, *)) &#123; modeImg = [modeImg imageByPreparingThumbnailOfSize:CGSizeMake(220, 100)]; NSLog(@"1.变换后图片原尺寸%@",NSStringFromCGSize(modeImg.size)); [modeImg prepareThumbnailOfSize:CGSizeMake(220, 100) completionHandler:^(UIImage * _Nullable) &#123; NSLog(@"2.变换后图片原尺寸%@",NSStringFromCGSize(modeImg.size)); &#125;];&#125; else &#123; // Fallback on earlier versions&#125;;//打印值//2021-12-15 15:48:17.590981+0800 iOS15UI[71637:683127] 图片原尺寸&#123;674, 206&#125;//2021-12-15 15:48:17.598647+0800 iOS15UI[71637:683127] 1.变换后图片原尺寸&#123;220, 100&#125;//2021-12-15 15:48:17.600537+0800 iOS15UI[71637:684293] 2.变换后图片原尺寸&#123;220, 100&#125; ## UISheetPresentationController增加UISheetPresentationController，通过它可以控制 Modal 出来的 UIViewController 的显示大小，且可以通过拖拽手势在不同大小之间进行切换。 123456if let presentationController = presentationController as? UISheetPresentationController &#123; // 显示时支持的尺寸 presentationController.detents = [.medium(), .large()] // 显示一个指示器表示可以拖拽调整大小 presentationController.prefersGrabberVisible = true&#125; CLLocationButton推出CLLocationButton用于一次性定位授权，该内容内置于CoreLocationUI模块，但如果需要获取定位的详细信息仍然需要借助于CoreLocation。 URLSessionURLSession 推出支持 async/await 的 API，包括获取数据、上传与下载]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS电话状态监听]]></title>
    <url>%2F2022%2F01%2F06%2FiOS%E7%94%B5%E8%AF%9D%E7%8A%B6%E6%80%81%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[一、iOS10之前 导入头文件 12#import &lt;CoreTelephony/CTCallCenter.h&gt; #import &lt;CoreTelephony/CTCall.h&gt; 代码 12345678910111213141516@property (strong, nonatomic) CTCallCenter *callCenter;self.callCenter = [[CTCallCenter alloc] init];self.callCenter.callEventHandler = ^(CTCall * call) &#123; if([call.callState isEqualToString:CTCallStateDisconnected]) &#123; NSLog(@"Call has been disconnected"); // 电话被挂断 &#125; else if([call.callState isEqualToString:CTCallStateConnected] &#123; NSLog(@"Call has been connected"); // 电话被接听 &#125; else if([call.callState isEqualToString:CTCallStateIncoming]) &#123; NSLog(@"Call is incoming"); // 来电话了 &#125; else if([call.callState isEqualToString:CTCallStateDialing]) &#123; NSLog(@"Call is Dialing"); // 拨号 &#125; else &#123; NSLog(@"Nothing is done"); &#125;&#125;; 二、iOS10之后iOS10及之后使用Callkit中的CXCallObserver和CXCall 导入头文件 12#import &lt;CallKit/CXCallObserver.h&gt; #import &lt;CallKit/CXCall.h&gt; 代码 1234567891011121314151617181920212223242526@property (strong, nonatomic) CXCallObserver *callObserver;// 电话监听if (!self.callObserver) &#123; self.callObserver = [[CXCallObserver alloc] init]; [self.callObserver setDelegate:self queue:dispatch_get_main_queue()];&#125;#pragma mark - 电话的监听- (void)callObserver:(CXCallObserver *)callObserver callChanged:(CXCall *)call &#123; NSLog(@"call observer uuid: %@", call.UUID); NSLog(@"outgoing(拨打) :%d onHold(待接通) :%d hasConnected(接通) :%d hasEnded(挂断) :%d",call.outgoing,call.onHold,call.hasConnected,call.hasEnded); /* 挂断 outgoing(拨打) :0 onHold(待接通) :0 hasConnected(接通) :0 hasEnded(挂断) :1 拨打 outgoing(拨打) :1 onHold(待接通) :0 hasConnected(接通) :0 hasEnded(挂断) :0 (拨打) outgoing(拨打) :1 onHold(待接通) :0 hasConnected(接通) :0 hasEnded(挂断) :1 (拨打 - 挂断) outgoing(拨打) :1 onHold(待接通) :0 hasConnected(接通) :1 hasEnded(挂断) :0 (拨打 - 接通) outgoing(拨打) :1 onHold(待接通) :0 hasConnected(接通) :1 hasEnded(挂断) :1 (拨打 - 接通 - 挂断) 接通 outgoing(拨打) :0 onHold(待接通) :0 hasConnected(接通) :1 hasEnded(挂断) :0 (接通) outgoing(拨打) :0 onHold(待接通) :0 hasConnected(接通) :1 hasEnded(挂断) :1 (接通 - 挂断)*/ if (call.hasConnected) &#123; /// 接通了电话 &#125; if (call.hasEnded) &#123; // 挂断 &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS封装SDK(分别生成.a和framework)]]></title>
    <url>%2F2021%2F11%2F26%2FiOS%E5%B0%81%E8%A3%85SDK-%E5%88%86%E5%88%AB%E7%94%9F%E6%88%90-a%E5%92%8Cframework%2F</url>
    <content type="text"><![CDATA[一、库的介绍 什么是库？库(Library)说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用 根据源代码的公开情况，库可以分为两种类型a.开源库：公开源代码，能看到具体实现，比如SDWebImage、AFNetworking b.闭源库：不公开源代码，是经过编译后的二进制文件，看不到具体实现，主. 要分为静态库、动态库 什么时候我们会用到库呢？ 一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。 (一些引入的第三方库) 对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。 (一些比较稳定的工具类，或者很稳定的功能模块) 静态库 静态库 (静态链接库) 以.a 和 .framework 结尾 。 只所以叫静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在程序里就不会在改变 优点：编译完成之后，库文件没有作用了，目标没有外部依赖，直接可以运行缺点： 链接时，静态库会被完整的复制到可执行文件中，被多次使用就有多份冗余拷贝，会使目标体积增大 动态库 动态库(动态链接库) 以 .dylib 或者 .framework 后缀结尾 与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。 优点：不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，运行时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。 缺点： 动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。（Linux lib not found 错误） 注意： 由于iOS8之后才允许使用插入动态库，所以网上大部分教程在选MachO-Type的时候选择的是Static Library。但是.a静态库和静态framework无法访问库中的资源图片的。所以自己创建的framework如果想访问库中的资源文件，那么必须要是动态库。 自建动态库手动拖入的工程后，必须选择embed选项，否则的话，启动即崩溃 相关链接🔗：iOS动态库、静态库及使用场景、方式 二、生成.framework 打开Xcode，新建工程，命名GJJDateToolSDK 设置参数 📢 Dead Code stripping Xcode 默认会开启此选项，C/C++/Swift 等静态语言编译器会在 link 的时候移除未使用的代码，但是对于 Objective-C 等动态语言是无效的。因为 Objective-C 是建立在运行时上面的，底层暴露给编译器的都是 Runtime 源码编译结果，所有的部分应该都是会被判别为有效代码。 Link With Standard Libraries ​ 设置NO，避免重复链接 arm64等CUP架构说明看CPU架构说明 系统默认会创建该文件，作用相当于项目中统一管理头文件的那个文件 新建文件，在GJJDateToolSDK.h中引入头文件。 在Build Phase进行如下配置，把公开文件放到Public下边，把需要隐藏的放到private下边。 继续进行如下配置 打包Framework。选中模拟器command + b，选中真机command + b。 查看编译好之后的framework 合并真机与模拟器编译后的framework文件通过lipo -create 命令合并 相关命令：lipo -create + 模拟器编译后的framework中的GJJDateToolSDK + 真机编译后的framework中的GJJDateToolSDK + -output + 合并后的要保存的路径 注意：合并模拟器编译后的静态库与真机编译后的静态库报错have the same architectures (arm64) and can&#39;t be in the same fat output file 查看步骤2设置参数是否添加Build Setting –&gt; Excluded Architectures –&gt; Release –&gt; 添加上 arm64 导出文件 将合并后的文件拖入到真机编译后的文件中进行替换，然后将整个GJJDateToolSDK.framework拷贝出，添加到项目中。至此制作完毕一个适用于真机与模拟器的framework静态库制作完毕。 三、生成.a 新建工程，以GJJDateToolSDK为例 配置参数 创建bundle文件,名字一般与工程名相同(如果静态库有资源文件要使用，必须放入.bundle文件) 写代码 将头文件公开 注意：如果头文件过多，可以新建一个.h文件统一引入，避免引用SDK的时候，需要导入过多.h文件 打包.a文件 选择模拟器和真机，分别进行command+b 合并真机与模拟器编译后的.a文件通过lipo -create 命令合并]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决webview全屏播放视频]]></title>
    <url>%2F2021%2F11%2F24%2F%E8%A7%A3%E5%86%B3webview%E5%85%A8%E5%B1%8F%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[问题背景：webview使用内部播放器播放视频，不是有iPhone默认播放器播放allowsInlineMediaPlayback指示HTML5视频是否内联播放(YES)或使用本机全屏控制器(NO)。默认值为NO。 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];config.allowsInlineMediaPlayback = YES;_webView= [[DWKWebView alloc] initWithFrame:CGRectZero configuration:config];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用hexo命令]]></title>
    <url>%2F2021%2F11%2F24%2F%E5%B8%B8%E7%94%A8hexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常见命令 hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 13新建项目Products目录显示方法]]></title>
    <url>%2F2021%2F11%2F24%2FXcode-13%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AEProducts%E7%9B%AE%E5%BD%95%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先打开项目，进入到项目目录找到xxx.xcodeproj文件显示包内容，找到project.pbxproj打开，搜索productRefGroup， 搜索结果可能有多个，每个项目的键值不一样具体看自己的注意看productRefGroup的注释 为/* Products */ 才是我们要修改的 12mainGroup = 2010E124274DE36A00A796DF;productRefGroup = 2010E12F274DE36A00A796DF /* Products */; 将上面 mainGroup 对应的值复制给 productRefGroup 的值 如下： 12mainGroup = 2010E124274DE36A00A796DF;productRefGroup = 2010E124274DE36A00A796DF /* Products */; 最后按 command+s 保存 project.pbxproj 文件,Xcode将自动刷新这时候你想见的 Products 目录就出现了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS上搭建Flutter开发环境]]></title>
    <url>%2F2019%2F09%2F18%2FmacOS%E4%B8%8A%E6%90%AD%E5%BB%BAFlutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[系统要求要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: macOS (64-bit) 磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）. 工具: Flutter 依赖下面这些命令行工具. bash、mkdir、rm、git、curl、unzip、which 获取Flutter SDK 去flutter官网下载其最新可用的安装包，官网地址：https://flutter.io/sdk-archive/#macos。注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，可以去Flutter github项目下去下载安装包，地址：https://github.com/flutter/flutter/releases 。 解压安装包到你想安装的目录直接解压放到你想安装的目录就可以。或者使用命令行： 12cd ~/developmentunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 配置环境变量 打开终端工具，使用vim进行配置环境变量，命令如下： 1vim ~/.bash_profile 然后在终端添加以下三行： 123export PUB_HOSTED_URL=https://pub.flutter-io.cn # 国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn # 国内用户需要设置export PATH=/Users/sheffi/flutter/bin:$PATH 配置完成后，需要用source命令重新加载一下 ，具体命令如下： 1source ~/.bash_profile 完成这些步骤后，可以使用命令进行检测一下，是否安装成功。 1flutter -h 如图，说明一切安装顺利 检查开发环境 到这我们已经安装好了flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查： 1flutter doctor 因为我所有的东西都安装完，显示如下 第一次安装根据终端的提示进行安装相应的软件和插件。 安装 Xcode 要为iOS开发Flutter应用程序，您需要Xcode 9.0或更高版本: 安装Xcode 9.0或更新版本(通过链接下载或苹果应用商店). 配置Xcode命令行工具以使用新安装的Xcode版本 sudo xcode-select –switch /Applications/Xcode.app/Contents/Developer 对于大多数情况，当您想要使用最新版本的Xcode时，这是正确的路径。如果您需要使用不同的版本，请指定相应路径。 确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了. 使用Xcode，您可以在iOS设备或模拟器上运行Flutter应用程序。 安装Android Studio要在Android设备上构建并运行Flutter程序都需要先安装Android Studio，可以先自行下载并安装Android Studio，在此不再赘述。 Android Studio 配置与使用 a. 需要安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。 Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。 b. 安装步骤： 启动Android Studio。 打开插件首选项 (macOS：Preferences&gt;Plugins, Windows：File&gt;Settings&gt;Plugins)。 选择 Browse repositories…，选择 flutter 插件并点击 install。 重启Android Studio后插件生效。 c. 创建Flutter应用 选择 File&gt;New Flutter Project 。 选择 Flutter application 作为 project 类型, 然后点击 Next。 输入项目名称 (如 myapp)，然后点击 Next。 点击 Finish。 等待Android Studio安装SDK并创建项目。 d. 运行应用程序 定位到Android Studio工具栏 在 target selector 中, 选择一个运行该应用的Android设备。如果没有列出可用，请选择 Tools&gt;AVD Manager 并在那里创建一个。 在工具栏中点击 Run图标 如果一切正常, 您应该在您的设备或模拟器上会看到启动的应用程序： VS Code的配置与使用VS Code是一个轻量级编辑器，支持Flutter运行和调试。 a. 安装flutter插件 启动 VS Code。 调用 View&gt;Command Palette…。 输入 ‘install’, 然后选择 Extensions: Install Extension action。 在搜索框输入 flutter ，在搜索结果列表中选择 ‘Flutter’, 然后点击 Install。 选择 ‘OK’ 重新启动 VS Code。b. 验证配置 调用 View&gt;Command Palette… 输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ action。 查看“OUTPUT”窗口中的输出是否有问题c. 创建Flutter应用 启动 VS Code 调用 View&gt;Command Palette… 输入 ‘flutter’, 然后选择 ‘Flutter: New Project’ action 输入 Project 名称 (如myapp), 然后按回车键 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 最后附上学习链接：Flutter中文网]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十七款PDF在线转换器]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%8D%81%E4%B8%83%E6%AC%BEPDF%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目前最全合集，收藏备用。 1、smallPDF：https://smallpdf.com/2、Online OCR：https://www.onlineocr.net/3、PDF to Word Converter：https://www.pdftoword.com/4、加加PDF：https://www.addpdf.cn/pdf-to-word5、ilovePDF：https://www.ilovepdf.com/6、PDFconverter：https://www.pdfconverter.com7、PDFbao：http://www.pdfbao.com/8、PDF转换器：http://www.pdfdo.com/9、cloudconvert：https://cloudconvert.com/pdf-to-doc10、迅捷PDF转换器：https://app.xunjiepdf.com/11、ApowerPDF）：https://www.apowersoft.cn/pdf-editor12、PDF2go：https://www.pdf2go.com/zh/13、ABBYY FineReader：http://ocr.abbyy.cn/14、PDF.IO：https://pdf.io/tw/15、PDFtodoc：http://pdf2doc.com/zh/16、pdfcandy：https://pdfcandy.com/17、Docs.Zone：https://docs.zone/]]></content>
      <categories>
        <category>PDF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[译] 成为一个优秀程序员的101个小建议]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AF%91-%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84101%E4%B8%AA%E5%B0%8F%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[原文作者：Emma Wedekind 原文链接：dev.to/emmawedekin… 1. 善用google⭐作为一名程序员，你要知道如何搜索问题的答案。学会有效的使用google，你将节省大量开发时间。注：国内程序员还是要遵守规则的情况下跨过那道墙看看 2. 谨慎承诺超额交付⭐让你的团队知道一项任务需要三周的时间，并在两周内完成，这比让他们知道相反的情况要好。通过谨慎承诺和超额交付，你会建立信任。 3. 善待产品设计人员，他们是你的朋友产品设计人员为用户的痛点提供解决方案。向他们学习，团结一致地构建有效的产品。 4. 找到一名导师找到一个可以学习和借鉴的人。如果你需要技术指导，Coding Coach会是一个不错的地方。 5. 成为一名导师做一个别人可以学习和借鉴的人。你可以尝试在Coding Coach成为别人的导师。这个网站并不是很了解，请自行斟酌。国内厉害的程序员也很多，掘金，知乎上找也可以。 6. 写些有用的评论写下有用的回答而不是问为什么，mark和灌水也没什么意思。 7. 合理的命名变量和函数名函数和变量应该准确地表示它们的用途，因此myCoolFunction不是一个好名字。 8. 给自己放个假我们都需要时间来缓解压力。去一个你一直想去的地方放个假。你的大脑和同事都会感谢你的。 9. 删除无用代码⭐没有理由积累更多技术债务。 10. 学会阅读代码⭐阅读代码是一项非常宝贵的被低估的技能。 11. 找到健康工作和生活平衡点结束一周的工作之后，周末放松一下。关闭工作通知，删除手机上的应用程序。 12. 只安排必要的会议能用邮件解决的就没必要开会，如果非要开，也应该让会议简短高效。 13. 结对编程结对编程可以让你同时扮演老师和学生的角色。 14. 写好邮件邮件的内容应该简洁而清晰，抓住重点。没人会想看你的四页邮件，兄弟。 15. 加入社区⭐和志同道合的人在一起会激励你走出低谷。 16. 清理你的分支⭐清理你的版本控制分支，就像在你的岳父母来访之前清理你的房子一样。如果你不再需要，请删掉它，不删留着过年啊。 17. 接纳萌新包容点，不要告诉别人不够好，不能进入这个行业。每个人都是有价值。 18. 活到老学到老你选择了一个需要不断学习的职业，学会爱上它。 19. 永不言弃这并不容易，但是我们都是从同一个地方开始，你也能做到。 20. 敢于接受有挑战性的任务⭐如果任务没有挑战，它就不会帮助你成长。 21. 项目开始前明确需求⭐在开撸之前，你应该了解验收标准，这将为你节省时间和痛苦。 22. 工欲善其事，必先利其器⭐拥有一套你熟悉的工具，了解哪些工具服务于哪些目的，以及项目何时可以从使用这些工具中获益。 23. 我们需要建设性的批评向信任的同事和朋友寻求建设性的批评，它将帮助你更优秀。 24. 保持开放思维⭐技术在变化，而且变化得很快。不要反对新技术，学习它，然后形成自己的观点。 25. 保持在技术前沿，不要掉队⭐通过关注出版物，博客，播客和科技新闻，及时了解最新的科技新闻。 26. 专注于解决问题⭐锻炼自己解决问题的能力，强大的解决问题的能力能够帮助你应付一切，专注于解决问题的方法。 27. 保持谦虚⭐三人行必有我师，无论你什么头衔，什么公司，都要保持谦逊。 28. 不光要代码写的好，PPT也要讲得好学习如何吸引你的听众，并给出有效的演示。 29. 选型如买菜，也要货比三家⭐给自己更多选择，在开展工作前，调研尽可能多的解决方案。 30. 找到自己的定位⭐科技产业也有很多分类，找到你最感兴趣的领域，并成为一名专家。 31. 养成好习惯⭐试着建立一致的、健康的习惯，比如保持专注，合理安排时间，出席会议，从最重要的任务开始。这可能需要一些时间来适应，但从长远来看是值得的。 32. 学会debug⭐探索浏览器调试器工具。学习使用IDE调试的细节。通过学习最有效的调试问题和跟踪错误的方法，再困难的bug也能搞定。 33. 锻炼你现有的技能⭐并不是说你已经掌握了一项技能就不需要再锻炼它。业精于勤荒于嬉，除非有意识地提高技能，否则技能会随着时间的推移而消失。而这个行业又发展得如此之快，坚持练习是很重要的。从“我一直都是这样做的”的心态中走出来，进入“有没有更好的方法来做这件事”的心态。仅仅是因为你现在拥有六块腹肌，不意味着你就可以每天吃一个🍩。 34. 了解原因⭐有时你必须表达自己的意见，因此了解其背后的原因非常重要。为什么解决方案A比解决方案B更好？提供有效的论据，你的意见将更加可靠。 35. 了解自己的价值技术也是商品，应该得到适当的报酬。了解你所在地区的行业平均水平。如果你赚的钱少了，是时候和你的老板谈谈，追求你应得的。 36. 不要害怕寻求帮助⭐如果你被困在一个问题上，花了太多时间寻找解决方案，是时候寻求帮助了。我们都是人，我们都需要帮助，寻求同事的援助并不可耻。 37. 学会学习⭐人们学习的方式不同，有些人通过视频教程学得最好，有些人通过阅读书籍学得最好。弄清楚你的学习风格，然后努力实践。 38. 与人为善有时你会被要求向同事提供反馈，友善一点，你可以对某位同事不够积极表达看法，而不是出言不逊。 39. 休息一下连续敲8个小时代码几乎是不可能，你很快就会筋疲力尽，犯很多错误。所以设个闹钟来提醒自己停下来休息一下。去散散步，和同事一起喝杯咖啡，远离屏幕会对你的工作效率和质量产生积极的影响。 40. 跟踪你的学习进度学习编程需要时间，当你看不到进展时，你会感到非常沮丧。所以跟踪你的成就和实现目标的进展非常重要。在你的电脑旁边放一个小清单，每次你完成一件事，把它写下来，不管它有多小，最终将会从量变到质变。 41. 不要依赖库和框架⭐掌握一个框架和库不如深入学习这门语言，没有必要一个接一个的学习这些库和框架，但是理解框架和库如何实现可以帮助你写出更简洁强壮的代码。 42. 学会爱上代码审查让别人阅读和分析你的代码可能会让你不安，但是可以提供宝贵的反馈，这会让你成为一个更好的程序员。而且你也应该提高进行良好代码评审的能力。 43. 多方位全面学习学习其他领域的基础知识, 如设计、营销、前端开发或后端开发。它将帮助你成为一个更全面的程序员。 44. 不要选择熟悉的技术，而应该是正确的⭐每个项目都有不同的需求，因此我们必须为这项工作选择合适的工具。尽管选择以前使用过的技术很方便，但是如果它们不适合项目的需要，应该探索其他替代方案。 45. 勇于承担责任⭐所有人都会犯错，在你的职业生涯中，你会犯很多很多的错误。因此，当你犯了错误时，站出来承担责任是很重要的，它将与你的团队成员和管理层建立信任。 46. 检查自己的代码⭐在发起PR请求之前，检查自己的代码，如果这是同事的工作，你会发表什么评论？在请求代码审查之前首先尝试自己诊断问题或错误非常重要，就像考试交卷前应该自己检查一遍。 47. 从失败中吸取教训⭐失败只是没有达到预期的结果，并不一定是件坏事。在我们的职业生涯中，我们会面临很多失败，从失败中学习下次你能做些什么。 48. 正视自己的缺点了解你自己，你的缺点是什么?也许你总是在推送之前忘记更新测试，或者你真的不擅长回复电子邮件。了解你的弱点，这样你就能积极地改善它们。 49. 保持好奇心⭐这个行业在不断发展，所以好奇心很重要。如果你不明白什么，不管是项目需求还是一行代码，大声说出来。没有人会因为你要求说明而批评你，你会因此创造出更好的代码。 50. 不要试图学习一切⭐世界上有无穷无尽的知识宝库，你不可能征服它。选择几个要掌握的主题，其余的就不要管了。你可以获得其他领域的相关知识，但你不可能掌握所有内容。 51. 该舍弃就舍弃仅仅因为你写了一些代码并不意味着你需要对它产生感情。没有人喜欢他们所做的工作被丢弃，但是代码有一个生命周期，所以没有必要一直保留着它。 52. 团队支持优秀的团队相互支持，这为尝试新事物创造了一个安全的空间，而不用担心受到惩罚。 53. 在社区中寻找鼓舞在行业里找几个你钦佩的人。它会激励你继续你的项目或尝试新事物 54. 重视并且珍惜你的工作不管你有多少经验或者你的职位是什么，你的工作都是有价值的，给予它应有的价值。 55. 排除干扰关掉闲置的通知、短信、电子邮件和社交媒体会帮助你集中精力，最大化你的工作日。晚30分钟回复你朋友的信息，他死不了，真有事就打电话了。 56. 乐于助人试着支持你的团队成员，无论是参加一个重要的演讲，还是在他们遇到困难时帮助他们。 57. 不要吝啬你的赞美⭐如果有人做得很好，告诉他们。正面反馈是与团队成员建立信任和帮助他们事业发展的好方法。他们也更有可能帮助你 58. 测试你的代码⭐测试是很重要的。单元测试、回归测试、集成测试、端到端测试。测试你的代码，你的产品将会更加稳定。 59. 制定应对计划当你收到一个新功能需求或bug修改时，先制定应对计划，你需要什么来解决这个问题或开发这个特性？花几分钟来做这件事，也许后面可以为你节省数小时的沮丧。 60. 掌握伪代码伪代码是一项很好的技能，因为它允许你在不浪费时间编写代码的情况下考虑复杂的问题。将一种方法写在纸上，运行不同的测试用例，看看缺陷在哪里。 61. 记录你的成就如果你在工作中获得了嘉奖，把它写下来。如果你开发了一个重要的功能，把它写下来。你会拥有一些积累、沉淀，它将有助于你职业晋升亦或在某一艰难的日子鼓舞你的士气。 62. 学习编程基础⭐学习一些基本的排序和搜索算法以及数据结构。它们与语言无关，可以帮助你跨语言解决问题。 63. 选择长期维护的技术尽管测试最新的技术很有趣，但是选择那些在企业应用程序中易于维护的技术。你们的团队将在未来的岁月里感谢你们。 64. 学习设计模式⭐设计模式是构建代码的有效工具。你可能不是每个项目都需要它们，但是对它们有一个基本的了解将有助于构建更大的应用程序。 65. 化繁为简⭐不要编写复杂的代码来展示你高超的编程技能，而要着眼于可读性和简单性。这将使你的团队成员更容易做出贡献。 66. 还清技术债务技术债务可能会对性能产生巨大影响，所以如果能够重构，就应该重构。（这个建议绝对是好的，但是现实中要面临诸多问题） 67. 优先小版本迭代与其每个月发布一次大规模的升级，不如更频繁地发布较小的变更。这样你不太可能会引入bug和破坏更改。 68. 尽早并经常提交⭐尽早提交和经常提交是确保你的工作保持干净的最好方法，并且还可以减少意外地恢复重要更改的压力。 69. 了解何时寻求帮助你不仅不应该害怕寻求帮助，而且你应该学会什么时候寻求帮助。在寻求帮助之前，你应该试着解决问题，并记录下你尝试的事情。但是当你被一个简单的问题难住一个多小时的时候，代价大于收益，你应该向同事求助。 70. 问一些有效的问题⭐当你问问题的时候，要尽可能的具体，（可以参考github提issue的要求）。 71. 工作中及时寻求反馈你的工作不需要完成就能得到反馈。如果你不确定方向，请一位值得信赖的同事来检查你的解决方案的有效性。 72. 阅读文档⭐文档是关于技术的最纯粹的事实来源，因此学习阅读文档可以快速帮助你成为专家。 73. 尽可能做出各种尝试⭐没有什么能阻止你尝试解决问题的方法，你有什么损失呢？ 74. 在会议上积极发言你的想法和意见是有价值的，所以参加会议将有助于你与你的团队和管理层建立融洽的关系。 75. 跨团队协作如果你有机会和公司里的其他团队一起工作，那就去争取吧。 76. 保持项目热情当你每周工作40个小时时，花时间做你感兴趣的项目是很重要的（72小时的话更要如此）。它们可以帮助你重新找回对编程的热爱，并尝试你在工作中可能无法接触到的新技术。 77. 确定你的职业目标⭐对你的职业生涯有一个理想的轨迹是很重要的。如果你不这样做，你就是在没有目标的情况下射箭。 78. 加入到讨论中来⭐在博客上发表评论，参与Twitter主题，参与社区活动，做一个积极的旁观者会比单纯的旁观学到更多东西。 79. 确定任务优先级学会确定任务的优先顺序将有助于提高您的工作效率，建立一个日常任务和长期任务待办事项列表，并按最重要的顺序排序。 80. 不要忽略细节细节可以在项目中产生很大的影响。 81. 信任你的同事你的同事因为他们的技能而被雇佣，交给他们工作，并相信他们能完成。 82. 学会委托如果你处于领导地位，学习如何有效地委派任务。它会节省你的时间，你不能做所有的事。 83. 不要拿自己和别人比较你唯一应该比较的是昨天的自己。 84. 找到你的盟友学习编程将是一个漫长而不怎么容易的过程，和那些帮助你成长并鼓励你坚持下去的人在一起。 85. 不要想一步登天⭐一开始考虑太多做一个大而全的项目会让你不堪重负。构建时要考虑可伸缩性，但在需要时才开始扩展。这样你就不会用不必要的膨胀来压倒你的团队，而是保持了成长的能力。 86. 衡量性能影响⭐如果你想使用一种很酷的新技术，你应该权衡这样做的性能影响。你能在不影响性能的情况下实现类似的功能吗？如果可以，你可能需要重新考虑你的方法了。 87. 技术歧视不可取⭐不要歧视新技术或新想法，对学习新技能的可能性保持开放的心态，也不要歧视他人，我们都值得尊重。（也不要歧视旧技术，即使现在前端框架盛行，但你也不能说Jquery就没有任何可取之处。） 88. 申请你不能胜任的工作你永远不可能满足工作的所有要求，所以抓住机会申请吧，你有什么损失呢？ 89. 模块化你的代码你可以在一个长文件中编写所有代码，但这是不可维护的。通过模块化，我们确保代码易于理解和测试。 90. 不要只是做代码的搬运工⭐如果你要复制并粘贴Stack Overflow中的解决方案，你应该确切地理解它的作用，有意识地选择要引入的代码。 91. 创造一个舒适的工作环境⭐如果你喜欢你的工作环境和技术设置，你会更有动力去工作，所以还在等什么？ 92. 记住你来自哪里我们都是从同一个地方开始的，随着你的技能和职位的发展，不要忘记你来自哪里，不要膨胀。 93. 试着保持乐观如果出了什么问题，试着乐观一点。明天是新的一天。乐观会帮助你的团队充满活力和精神健康。 94. 不断重新评估你的工作流程⭐仅仅因为某样东西现在有效，并不意味着它永远有效。重新评估你的工作流程，并在必要时做出调整。 95. 学会在家办公如果你有能力在家工作，那就学会有效地在家工作。找一个独立的办公空间，远离干扰。Boneskull写了一篇很棒的关于在家工作的文章，你应该看看。 96. 无障碍代码无障碍不是事后才想到的，也不一定很难，每个人都应该能够使用你的产品。 97. 遵守你的承诺⭐如果你告诉别人你会在某一天完成某件事，要信守承诺。如果你不能在截止日期前完成任务，那就早点说出来。 98. 积极主动如果你有额外的精力，找一个任务来帮助你的团队，他们会很感激你是主动的。 99. 创建一个令人惊叹的作品集一个优秀的作品集让你与众不同，使用它作为展示你的编程和设计技巧的机会！ 100. 记住你喜欢编程的原因⭐你进入这个行业是因为它激发了你的兴趣，如果你感到沮丧和怨恨，休息一下，给自己空间重新点燃你对编程的激情。 101. 分享你的知识⭐如果你学到了一些很酷的东西，不要吝惜分享它，参加当地的技术交流会，在午餐时间教你的同事或学员，分享你的知识可以让更多人受益同时自己也能巩固提高。 最后多加两条： 102. 条适当锻炼和103. 条充足睡眠]]></content>
      <categories>
        <category>译文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS内购相关封装]]></title>
    <url>%2F2019%2F05%2F28%2FiOS%E5%86%85%E8%B4%AD%E7%9B%B8%E5%85%B3%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[将内购相关d功能封装成单例类，直接上代码.h相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import &lt;Foundation/Foundation.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@protocol YYAInAppPurchaseToolDelegate &lt;NSObject&gt;/*** TODO: System error.*/- (void)IAPToolSysWrong;/*** 已刷新可购买商品** @param products 商品数组*/- (void)IAPToolGotProducts:(NSMutableArray *)products;/*** 购买成功** @param productID 购买成功的商品ID*/- (void)IAPToolBoughtProductSuccessedWithProductID:(NSString *)productIDandInfo:(NSDictionary *)infoDic;;/*** 取消购买** @param productID 商品ID*/- (void)IAPToolCanceldWithProductID:(NSString *)productID;/*** 购买成功，开始验证购买** @param productID 商品ID*/- (void)IAPToolBeginCheckingdWithProductID:(NSString *)productID;/*** 重复验证** @param productID 商品ID*/- (void)IAPToolCheckRedundantWithProductID:(NSString *)productID;/*** 验证失败** @param productID 商品ID*/- (void)IAPToolCheckFailedWithProductID:(NSString *)productIDandInfo:(NSData *)infoData;/*** 恢复了已购买的商品（永久性商品）** @param productID 商品ID*/- (void)IAPToolRestoredProductID:(NSString *)productID;@endNS_ASSUME_NONNULL_BEGIN@interface YYAInAppPurchaseTool : NSObjecttypedef void(^BoolBlock)(BOOL successed,BOOL result);typedef void(^DicBlock)(BOOL successed,NSDictionary *result);/*** 代理*/@property(nonatomic,weak) id &lt;YYAInAppPurchaseToolDelegate&gt; delegate;/*** 购买完后是否在iOS端向服务器验证一次,默认为YES*/@property(nonatomic)BOOL CheckAfterPay;/*** 单例** @return YQInAppPurchaseTool*/+(YYAInAppPurchaseTool *)defaultTool;/*** 询问苹果的服务器能够销售哪些商品** @param products 商品ID的数组*/- (void)requestProductsWithProductArray:(NSArray *)products;/*** 用户决定购买商品** @param productID 商品ID*/- (void)buyProduct:(NSString *)productID;/*** 恢复商品（仅限永久有效商品）*/- (void)restorePurchase;@endNS_ASSUME_NONNULL_END .m相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#import &quot;YYAInAppPurchaseTool.h&quot;#ifdef DEBUG#define checkURL @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;#else#define checkURL @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;#endif@interface YYAInAppPurchaseTool ()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;/*** 商品字典*/@property(nonatomic,strong)NSMutableDictionary *productDict;@end@implementation YYAInAppPurchaseToolstatic YYAInAppPurchaseTool *storeTool;/// 单例+ (YYAInAppPurchaseTool *)defaultTool &#123;if(!storeTool)&#123;storeTool = [YYAInAppPurchaseTool new];[storeTool setup];&#125;return storeTool;&#125;#pragma mark 初始化- (void)setup &#123;self.CheckAfterPay = YES;// 设置购买队列的监听器[[SKPaymentQueue defaultQueue] addTransactionObserver:self];&#125;/// 询问苹果的服务器能够销售哪些商品- (void)requestProductsWithProductArray:(NSArray *)products &#123;NSLog(@&quot;开始请求可销售商品&quot;);// 能够销售的商品NSSet *set = [[NSSet alloc] initWithArray:products];// &quot;异步&quot;询问苹果能否销售SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:set];request.delegate = self;// 启动请求[request start];&#125;#pragma mark 获取询问结果，成功采取操作把商品加入可售商品字典里/*** 获取询问结果，成功采取操作把商品加入可售商品字典里** @param request 请求内容* @param response 返回的结果*/- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response &#123;if (self.productDict == nil) &#123;self.productDict = [NSMutableDictionary dictionaryWithCapacity:response.products.count];&#125;NSMutableArray *productArray = [NSMutableArray array];for (SKProduct *product in response.products) &#123;//NSLog(@&quot;%@&quot;, product.productIdentifier);// 填充商品字典[self.productDict setObject:product forKey:product.productIdentifier];[productArray addObject:product];&#125;//通知代理[self.delegate IAPToolGotProducts:productArray];&#125;#pragma mark - 用户决定购买商品/*** 用户决定购买商品** @param productID 商品ID*/- (void)buyProduct:(NSString *)productID &#123;SKProduct *product = self.productDict[productID];// 要购买产品(店员给用户开了个小票)SKPayment *payment = [SKPayment paymentWithProduct:product];// 去收银台排队，准备购买(异步网络)[[SKPaymentQueue defaultQueue] addPayment:payment];&#125;#pragma mark - SKPaymentTransaction Observer#pragma mark 购买队列状态变化,,判断购买状态是否成功/*** 监测购买队列的变化** @param queue 队列* @param transactions 交易*/- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions &#123;// 处理结果for (SKPaymentTransaction *transaction in transactions) &#123;NSLog(@&quot;队列状态变化 %@&quot;, transaction);// 如果小票状态是购买完成if (SKPaymentTransactionStatePurchased == transaction.transactionState) &#123;//NSLog(@&quot;购买完成 %@&quot;, transaction.payment.productIdentifier);if(self.CheckAfterPay)&#123;//需要向苹果服务器验证一下//通知代理[self.delegate IAPToolBeginCheckingdWithProductID:transaction.payment.productIdentifier];// 验证购买凭据[self verifyPruchaseWithID:transaction.payment.productIdentifier];&#125;else&#123;//不需要向苹果服务器验证//通知代理[self.delegate IAPToolBoughtProductSuccessedWithProductID:transaction.payment.productIdentifierandInfo:nil];&#125;// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125; else if (SKPaymentTransactionStateRestored == transaction.transactionState) &#123;//NSLog(@&quot;恢复成功 :%@&quot;, transaction.payment.productIdentifier);// 通知代理[self.delegate IAPToolRestoredProductID:transaction.payment.productIdentifier];// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125; else if (SKPaymentTransactionStateFailed == transaction.transactionState)&#123;// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];//NSLog(@&quot;交易失败&quot;);[self.delegate IAPToolCanceldWithProductID:transaction.payment.productIdentifier];&#125;else if(SKPaymentTransactionStatePurchasing == transaction.transactionState)&#123;NSLog(@&quot;正在购买&quot;);&#125;else&#123;NSLog(@&quot;state:%ld&quot;,(long)transaction.transactionState);NSLog(@&quot;已经购买&quot;);// 将交易从交易队列中删除[[SKPaymentQueue defaultQueue] finishTransaction:transaction];&#125;&#125;&#125;#pragma mark - 恢复商品/*** 恢复商品*/- (void)restorePurchase &#123;// 恢复已经完成的所有交易.（仅限永久有效商品）[[SKPaymentQueue defaultQueue] restoreCompletedTransactions];&#125;#pragma mark 验证购买凭据/*** 验证购买凭据** @param ProductID 商品ID*/- (void)verifyPruchaseWithID:(NSString *)ProductID &#123;// 验证凭据，获取到苹果返回的交易凭据// appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];// 从沙盒中获取到购买凭据NSData *receiptData = [NSData dataWithContentsOfURL:receiptURL];// 发送网络POST请求，对购买凭据进行验证//In the test environment, use https://sandbox.itunes.apple.com/verifyReceipt//In the real environment, use https://buy.itunes.apple.com/verifyReceipt// Create a POST request with the receipt data.NSURL *url = [NSURL URLWithString:checkURL];NSLog(@&quot;checkURL:%@&quot;,checkURL);// 国内访问苹果服务器比较慢，timeoutInterval需要长一点NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:20.0f];request.HTTPMethod = @&quot;POST&quot;;// 在网络中传输数据，大多情况下是传输的字符串而不是二进制数据// 传输的是BASE64编码的字符串/**BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性BASE64是可以编码和解码的*/NSString *encodeStr = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];NSString *payload = [NSString stringWithFormat:@&quot;&#123;\&quot;receipt-data\&quot; : \&quot;%@\&quot;&#125;&quot;, encodeStr];NSData *payloadData = [payload dataUsingEncoding:NSUTF8StringEncoding];request.HTTPBody = payloadData;// 提交验证请求，并获得官方的验证JSON结果NSURLSession *session = [NSURLSession sharedSession];// 4.根据会话对象，创建一个Task任务NSURLSessionDataTask *sessionDataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;NSLog(@&quot;从服务器获取到数据&quot;);NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:(NSJSONReadingMutableLeaves) error:nil];if (dict != nil) &#123;// 验证成功,通知代理// bundle_id&amp;application_version&amp;product_id&amp;transaction_id[self.delegate IAPToolBoughtProductSuccessedWithProductID:ProductIDandInfo:dict];&#125; else &#123;//验证失败,通知代理[self.delegate IAPToolCheckFailedWithProductID:ProductIDandInfo:data];&#125;&#125;];[sessionDataTask resume];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内购</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native开发环境的搭建（Mac）]]></title>
    <url>%2F2019%2F05%2F24%2FReact-Native%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88Mac%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装依赖1.先安装Homebrew（若已安装，可跳过）1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/ 2.安装node和webpack 12brew install nodebrew install webpack 测试node和webpack是否安装成功，可用如下命令进行检测。若本地安装，则会显示对应版本号。12node -vwebpack -v 3.设置国内镜像（常年开vpn的可以忽略）1npm config set disturl https://npm.taobao.org/dist --global 这里出错了，按提示走就可以，复制sudo那一行更改目录权限，再设置国内镜像。 4.安装RN：直接输入npm install -g react-native-cli。会因为权限不够而报错：npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules。所以我们直接输入下面两句话12sudo chown -R $(whoami) /usr/local/*npm install -g yarn react-native-cli 测试是否安装成功：1react-native -v 创建RN项目到本地1.创建RN项目1react-native init AwesomeProject 2.编译并运行 React Native 应用12cd AwesomeProjectreact-native run-ios 提示：如果 run-ios 无法正常运行，请使用 Xcode 运行来查看具体错误（run-ios 的报错没有任何具体信息）。第一次运行会比较慢，需要耐心等待一下 3.修改项目现在你已经成功运行了项目，我们可以开始尝试动手改一改了： 使用你喜欢的编辑器打开App.js并随便改上几行。 在 iOS 模拟器中按下⌘-R就可以刷新 APP并看到你的最新修改！（如果没有反应，请检查模拟器的 Hardware 菜单中，connect hardware keyboard 选项是否选中开启） 大功告成]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS截图那些事]]></title>
    <url>%2F2018%2F09%2F06%2FiOS%E6%88%AA%E5%9B%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[普通view截图12345678910+ (UIImage *)gjj_viewScreenShot:(UIView *)view &#123;UIGraphicsBeginImageContextWithOptions(CGSizeMake(view.frame.size.width, view.frame.size.height ), NO, 0.0);[view.layer renderInContext:UIGraphicsGetCurrentContext()];/// 返回一个基于当前图形上下文的图片UIImage *viewImage = UIGraphicsGetImageFromCurrentImageContext();/// 移除栈顶的基于当前位图的图形上下文UIGraphicsEndImageContext();return viewImage;&#125; tableView、collectionView等scrollView生成长截图实现步骤 保存scrollView截取前的偏移量及Frame 计算出你要截取的长图的高度及宽度，即scrollView的contentSize，将scrollView.frame设成scrollView.contentSize 渲染出scrollView整体（上下文），截取当前scrollView生成Image 恢复scrollView的偏移量及Frame 12345678910111213141516+ (UIImage *)gjj_scrollViewScreenShot:(UIScrollView *)scrollView &#123;UIImage *image = nil;UIGraphicsBeginImageContextWithOptions(scrollView.contentSize, YES, [UIScreen mainScreen].scale);CGPoint saveContentOffset = scrollView.contentOffset;CGRect savedFrame = scrollView.frame;scrollView.contentOffset = CGPointZero;scrollView.frame = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height);[scrollView.layer renderInContext:UIGraphicsGetCurrentContext()];scrollView.layer.contents = nil;image = UIGraphicsGetImageFromCurrentImageContext();scrollView.contentOffset = saveContentOffset;scrollView.frame = savedFrame;UIGraphicsEndImageContext();return image;&#125; webView生成长截图webView和scrollView的截图大同小异 12345678910111213141516+ (UIImage *)gjj_webViewScreenShot:(UIWebView *)webView &#123;UIImage *image = nil;UIGraphicsBeginImageContextWithOptions(webView.scrollView.contentSize, YES, [UIScreen mainScreen].scale);CGPoint saveContentOffset = webView.scrollView.contentOffset;CGRect savedFrame = webView.frame;webView.scrollView.contentOffset = CGPointZero;webView.frame = CGRectMake(0, 0, webView.scrollView.contentSize.width, webView.scrollView.contentSize.height);[webView.layer renderInContext:UIGraphicsGetCurrentContext()];webView.layer.contents = nil;image = UIGraphicsGetImageFromCurrentImageContext();webView.scrollView.contentOffset = saveContentOffset;webView.frame = savedFrame;UIGraphicsEndImageContext();return image;&#125; 图片拼接很多需求是截图附带二维码等进行分享。 123456789101112131415161718192021222324+ (UIImage *)gjj_addHeadImage:(UIImage *)headImage footImage:(UIImage *)footImage toMasterImage:(UIImage *)masterImage &#123;CGSize size;size.width = masterImage.size.width;CGFloat headProportion = !headImage?0:(headImage.size.width / headImage.size.height);CGFloat footProportion = !footImage?0:(footImage.size.width / footImage.size.height);CGFloat headHeight = !headImage? 0:masterImage.size.width/headProportion;CGFloat footHeight = !footImage? 0:footImage.size.width/footProportion;size.height = masterImage.size.height + headHeight + footHeight;UIGraphicsBeginImageContextWithOptions(size, YES, 0.0);if (headImage) &#123;[headImage drawInRect:CGRectMake(0, 0, masterImage.size.width, headHeight)];&#125;[masterImage drawInRect:CGRectMake(0, headHeight, masterImage.size.width, masterImage.size.height)];if (footImage) &#123;[footImage drawInRect:CGRectMake(0, masterImage.size.height + headHeight, masterImage.size.width, footHeight)];&#125;UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();return resultImage;&#125; 添加水印12345678910+ (UIImage *)gjj_addWaterImage:(UIImage *)waterImage toMasterImage:(UIImage *)masterImage waterImageRect:(CGRect)rect &#123;UIGraphicsBeginImageContextWithOptions(masterImage.size, NO, 0);[masterImage drawInRect:CGRectMake(0, 0, masterImage.size.width, masterImage.size.height)];/// 绘制水印图片到当前上下文[waterImage drawInRect:rect];UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return newImage;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C实现】给出一个字符串，要求将其按照单词顺序进行反转]]></title>
    <url>%2F2018%2F08%2F21%2F%E3%80%90C%E5%AE%9E%E7%8E%B0%E3%80%91%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%A6%81%E6%B1%82%E5%B0%86%E5%85%B6%E6%8C%89%E7%85%A7%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目：给出一个字符串，要求将其按照单词顺序进行反转，比如如果是”the sky is blue”,那么反转之后的结果就是”blue is sky the”。问题分析： 每个单词长度不一致 空格需要特殊处理 使用C语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void swap (char chars[], int p, int q);void reverse (char chars[], int start, int end);void reverseWords(char strings[]);int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;char string[] = &quot;the sky is blue&quot;;reverseWords(string);&#125;return 0;&#125;void swap (char chars[], int p, int q) &#123;char temp = chars[p];chars[p] = chars[q];chars[q] = temp;&#125;void reverse (char chars[], int start, int end) &#123;NSLog(@&quot;%s&quot;,chars);int s = start;int e = end;while (s &lt; e) &#123;swap(chars, s, e);s += 1;e -= 1;&#125;NSLog(@&quot;%s&quot;,chars);&#125;void reverseWords(char strings[]) &#123;if ((int)strlen(strings) == 0) &#123;return;&#125;int start = 0, len = (int)strlen(strings);reverse(strings, 0, len - 1);for (int i = 0 ; i &lt; len; i++) &#123;if ((i == len - 1) || (strings[i + 1] == &apos; &apos;)) &#123;reverse(strings, start, i);start = i + 2;&#125;&#125;NSLog(@&quot;%s&quot;,strings);&#125; 控制台打印：2018-08-14 16:04:22.815076+0800 算法[6268:668783] blue is sky the]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLPreviewController]]></title>
    <url>%2F2018%2F05%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[QLPreviewController在iOS中用于方便预览文件，它支持的文件有： iWork文档 微软Office97以上版本的文档 RTF文档 PDF文件 图片文件 文本文件和CSV文件 使用的时候首先要引用#import &lt;QuickLook/QuickLook.h&gt;。 初始化： 12345_qlPreviewController = [[ QLPreviewController alloc]init]; _qlPreviewController.dataSource = self; _qlPreviewController.delegate = self; [self presentViewController:_qlPreviewController animated:YES completion:nil]; QLPreviewController类似于Tableview的使用方法，也是首先遵循代理和数据源代理。然后实现代理方法，如下： 123456789-(NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller&#123; return 2;&#125;-(id&lt;QLPreviewItem&gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;aa&quot; ofType:@&quot;doc&quot;]; NSURL *myDoucment = [NSURL fileURLWithPath:path]; return myDoucment;&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
  </entry>
</search>
